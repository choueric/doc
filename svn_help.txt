/*
 * subversion搭建和使用的简要指南
 * 
 * 该文档只是在阅读svnbook和进行一些实践之后得到的经验，具体和全面的介绍还是要
 * 参考svnbook。
 * 如果文档中有失误，请及时纠正，3ks。
 *
 * $CreatedBy: zhs $
 * $LastChangedRevision: 10 $
 * $LastChangedDate: 2011-02-22 00:52:59 +0800 (二, 2011-02-22) $
 * $LastChangedBy: zhs $
 * $URL: svn://armserver/home/arm/work/svn/doc_repos/svn_help.txt $
 */

用于在服务器armserver上的subversion的版本是1.6.6， 参考的手册svnbook针对的软件
版本是1.4，但是没有什么大的关系，应该是兼容的。

index:
- 一些基本概念
- 客户端基本操作
  - 获得工作拷贝
  - 查看工作拷贝
  - 典型的工作流程
  - 更新工作拷贝
  - 修改工作拷贝
  - 检查修改
  - 解决冲突(合并别人的修改)
  - 提交修改
  - 查看历史
  - 属性操作
  - 定制subversion
- 分支
  - 创建分支
  - 在分支上工作
  - 从主线上复制修改
  - 从主线上复制修改
  - 找回删除的文件
- 版本库管理
  - 创建版本库
  - 忽略不需要版本化的文件
  - 关键字替换
  - 管理版本库
  - 用户认证
- tips

/*------------------------------ 分割线 -----------------------------------*/

/*** 一些基本概念 ****/
- 版本库 Repository: 远端服务器上的统一管理项目文件的仓库；
- 工作拷贝：也即工作副本，位于你自己的本地。包括一些subversion创建并维护的额外
  文件以便来协助执行工作，通常每个文件夹下有个名为.svn的目录即是，这被称之为副
  本的管理目录。
- 发布：事实上就是将你自己的本地的工作拷贝的修改提交到版本库中，以便其他人能够
  看到，即为发布。
- 过期：自己在取得一份拷贝后，经修改后写入到版本库时，如果在修改过程中已经有人
  更新过版本库了，则此时你手上的那份本地拷贝就过期了。此时你应该将新的版本与自
  己修改后的版本进行合并，可能会发生冲突，需要手动解决，此时可能需要你与更新了
  版本库的那个人进行交流以解决冲突。
- 还是需要人工来解决冲突；
- 检出 check out: 即从版本库中获得一个工作拷贝。
- 提交 check in 或者 commit: 将修改好的工作拷贝提交到版本库中，进行发布。
- 可以单独提交一个文件。
- 冲突: 在你修改工作拷贝之后，如果此前已经有别人更新了版本库，则如果你的修改和
  别人的已经提交了的更改是同一个文件，则可能会发生冲突。如果修改是可合并的，比
  如一个修改文件头部，一个修改文件尾部，则不会产生冲突，版本库会合并该文件的两
  次修改。但如果是对文件的同一行进行修改则会产生冲突，这是需要手工解决冲突。你
  需要首先update，了解哪里发生了冲突，解决后才能提交。
- 更新 update: 这时你已经有了一个工作拷贝,通过该命令将结合其他人在你上次提交后
  的改变到你的工作拷贝，可以使你的工作拷贝保持最新。
- 修订 revision:每次版本库接受了一次提交，文件系统进入一个新的状态，称为一次修
  订。每一个修订版本被赋予一个自然数的版本号(或修订号)。 初始为0，只创建一个空
  目录，没有任何内容。并且版本号是针对整个项目的目录树的，而不是单个文件。
- 假设你当前的工作拷贝的版本号为10，但你修改工作拷贝并且提交给版本库之后，版本
  库的版本号变成15(可能在你check out和check in之间有其他用户进行了提交)， 但是
  你当前的工作拷贝的版本号仍然是10。也就是说，svn commit不会拖出任何新的修改。
  事实上，只有修改了的文件在提交后版本号编程15，而其他未修改的文件版本号不变，
  并且之后运行svn update之后，整个工作拷贝才能被标记为版本号15。

/*------------------------------ 分割线 -----------------------------------*/

/*** 客户端基本操作 ***/
如果不想一直用ip来表示服务器，可以在你本地电脑的/etc/hosts文件内添加主机名：
  192.168.0.188 armserver
其中，192.168.0.188为实验室subversion所在的服务器的IP，armserver为服务器设置好
的主机名。通过这样的设置之后，在你本地访问该服务器就不需要再输入具体的IP地址，
直接使用armserver就可以来访问该ip地址的主机了，即服务器。

/* add 2010年11月23日 星期二 16时37分21秒 */
因为学校网络该为动态获取，因此给服务器增加了一个网卡。eth0为内部网络接口，配置
为static，ip是192.168.0.188；而eth1为外部网络接口， 面向实验室网络的，按照要求
配置为DHCP，因此ip是动态获得的，目前稳定为172.20.69.133。
/* end */

服务器上搭设的subversion服务，对实验室中的项目源码以及文档进行了版本控制。仓库
根目录的路径为：
    svn://armserver/home/arm/work/svn/

在这里的svn仓库采用的是一个项目一个仓库的组织方式。 因此该目录下的每个目录都代
表了一个项目仓库。目前已有的仓库有：
- demo_repos：用于进行svn入门学习用，随便操作吧。
- doc_repos：实验室相关文档的仓库。
- mm_repos：笔者自己的一个小软件的仓库^_^。
- monitor_repos：多参数监护仪的仓库。
- sp_print_repos：用于多参数监护仪中的热敏打印机驱动的仓库。
- ventilator_repos：呼吸机的仓库。

关于subversion的操作可以参考svn_book.pdf和实验室的文档svn_help.txt。文档均位于
ftp://armftp/work/svn目录下。

你可以使用svn://armserver/home/arm/work/svn/demo_repos/trunk进行练习，你可以随
便折腾。而其他的则是正式的版本库，请不要随意改动。

首先，你需要安装一个subversion的客户端。各种命令帮助可以通过svn help来取得，具
体某个命令的详细说明，使用svn help command来获得。

/* 获得工作拷贝 */
$ svn checkout 或者 $ svn co
$ svn checkout svn://armserver/home/arm/work/svn/demo_repos/trunk demo_svn
则会在当前目录下建立目录monitor，里面存放源码，内容与服务端trunk下一致。如果该
命令在URL后面不带参数monitor，则会直接在当前目录下建立目录trunk。

/* 查看工作拷贝 */
在取得了一份工作拷贝之后，你可能会想要了解这个项目的一些情况，例如有哪些文件、
谁在什么时候对什么文件做了哪些修改已经相应的修改日志等。在你的开发过程中，你也
同样需要了解这些情况。这样的话，你可以使用以下的命令。

- $ svn list 或 $ svn ls
  用于列出版本库目录的条目。(貌似和本地拷贝没有关系，不过也很有用了)
  在没有工作拷贝的情况下，你想要查看版本库里有什么文件和目录，可以使用该命令。
  例如：$ svn list  svn://armserver/home/arm/work/svn/demo_repos/trunk，就可以
  看到该目录下有什么内容了。 如果加上--verbose(-v)参数，可以得到更多详细信息。
  如果该命令没有任何参数， 则缺省使用当前工作拷贝的版本库URL，而不是本地拷贝的
  目录。这就意味，你需要一个本地工作拷贝。也就是说，如果你没有工作拷贝，你需要
  指定该命令的目标参数，即版本库的URL； 但是如果你有了本地拷贝，则不需要显式指
  定版本库的URL，缺省的参数就可以指定要正确的URL了，并且默认的版本号也为当前工
  作拷贝的版本号。

- $ svn info
  即可以用来显示本地工作拷贝的文件信息， 也可以通过URL显示版本库里某个文件的信
  息。例如：$ svn info fs.c，就会显示本地的工作拷贝里的文件fs.c的信息；$ svn  
  info svn://armserver/home/arm/work/svn/demo_repos/trunk/fs.c，则显示的是远程
  版本库中的文件fs.c的信息。通过该命令可以查看当前版本号，最后的修改人等信息。
  不带参数，则显示工作拷贝当前目录的信息。

- $ svnversion
  直接用该命令可以查看工作拷贝的修订版本号。

你也可以使用命令:$ svn st -v来查看目录下所有条目的比较详细的信息。该命令事实上
是svn staus的别名，具体查看该命令的说明。

/* 典型的工作流程 */
日常生活中，很多命令是用不到的，这里假设你在本地已经有了一个工作拷贝。每一天当
你在subversion基础上进行项目开发时，你的工作流程基本上就如下所示：
- 更新你的工作拷贝
  $ svn update
- 做出修改
  修改已有文件
  $ svn add
  $ svn delete
  $ svn copy
  $ svn move
- 检验修改
  $ svn status
  $ svn diff
- 可能会取消一些修改
  $ svn revert
- 解决冲突(合并他人的修改)
  $ svn update
  $ svn resolved
- 最后提交你的修改
  $ svn commit

当你要开始开发时，首先应该更新你的工作拷贝，查看是否有其他人在此之前提交了新的
修改，了解修改或者检查该修改是否合理等。在更新没有问题之后，你就可以在当前工作
拷贝上进行你自己的工作了。如果只是修改已有的源文件，则不需要做其他工作，使用你
自己编辑器进行修改即可，subversion会自动检测到这种修改；但是如果你需要进行拷贝
文件、删除、添加、移动操作时，你就需要使用特定命令通知subversion这种改变了，而
不能够直接使用系统的move、cp等操作来进行。在你测试完了代码修改之后，想要提交之
前，你应当检验你的修改，查看是否有误操作，以便在提交之前在本地就修正这些操作。
在提交之前，最好使用update，查看在你修改过程中是否有其他人提交了新的修改，这些
新的修改可能会和你刚才进行的修改有冲突；当然，如果你不进行更新操作，在你提交的
时候，如果真的有其他修改提交了，你的提交也会失败并提示你解决可能的冲突。在解决
了冲突之后提交，注意，提交后版本库的版本号会增加，但是你的工作拷贝的版本号不会
更新，你需要运行update来更新。这样你的一次开发周期就结束了。

这里建议：提交的时刻并不一定是每天一次，而应该是你进行某一个功能的添加，并且经
过测试，确定该功能添加完善之后再提交修改；或者是发现了一个bug，要进行bug修正，
并且经过反复测试确定该bug已经被修正再进行提交。 同时，每次提交时的日志信息应当
详细地说明这次提交的修改做了哪些工作。

/* 更新工作拷贝 */
$ svn update 或 $ svn up
在命令执行中，每个条目之前会有一个字母，来让你知道subversion为保持最新，对你的
工作拷贝做了哪些工作。
- A: 添加
- D: 删除
- U: 更新
- C: 冲突
- G: 合并
在最后一行输出，可以知道你现在的工作拷贝更新到的版本号。

/* 修改工作拷贝 */
如果只是修改已存在的文件，不需要使用特定命令告知subversion你做的修改，应为它会
自动检测文件的更改。但是如果是对目录树进行修改，包括添加、删除、拷贝和移动，则
需要使用特定命令来进行。
- $ svn add foo
  如果foo是目录，所有foo中内容也会添加进去，如果只想添加foo本身，使用-N参数。
- $ svn delete foo 或 $ svn del foo 或 $svn rm foo
  如果foo是文件，马上会从工作拷贝中被删除，如果是目录，不会被删除， 但是系统准
  备好删除了，但你提交你的修改，foo就会在本地工作拷贝和服务端版本库中被删除。
- $ svn copy 或 $ svn cp
  该命令会立刻在本地的工作拷贝上产生效果。如果是从本地copy到版本库，则会引起一
  个立即提交。本地到本地只是产生一个预定拷贝，版本库不发生变化。
- $ svn move 或 $ svn mv
  只能在本地到本地或者版本库到版本库来移动。如果是本地，则只会影响工作拷贝，如
  果是操作版本库，则会产生一个立即提交。
- $ svn mkdir blor
  在本地立刻新建一个目录，但是版本库里不会，只是预定会创建。如果后面的目标是使
  用URL，则会直接在版本库里新建一个目录，并且立刻提交，使版本号增加。

/* 检查修改 */
在完成修改之后，需要提交修改到版本库，但在此之前，检查一下做过什么修改，可以得
到一份精确的日志信息，可以发现不小心修改的文件，给了你因此回复修改的机会。你可
以通过命令svn status浏览所做的修改，通过命令svn diff检查修改的详细信息。同样命
令svn revert有可以用来修正修改。值得注意的是，这些命令的执行并不需要与服务端的
版本库通讯和打交道，完全是在本地进行的操作。

- $ svn status 或 $ svn st
  这个命令可能会是你用到最多的命令。如果在工作拷贝的顶级目录下运行不带参数的该
  命令，则会检测你做的所有的文件或目录的修改。具体的符号意义如下：
  - A foo: 预定加入到版本库的文件、目录或软链接
  - C foo: 文件foo发生冲突，在从服务器更新时与本地版本发生交迭，在你提交到版本
    库前，必须手工解决冲突。(TODO: 这个冲突是什么意思？)
  - D foo: 文件、目录或是软链接foo预定从版本库中删除。
  - M foo: 文件foo的内容被修改了。
  - L foo: foo被锁定了，需要cleanup。
  - I foo: foo被忽略了。
  - ? foo: foo为未版本化文件。
  - R foo: 条目在工作拷贝中已经被替换了。 这意味着文件预定要删除，然后有一个同
    样名称的文件要在同一个位置替换它。
  - X foo: 条目与外部定义相关。
  - ! foo: 条目已经丢失。这也说明一个目录不是完整的(一个检出或更新中断)。
  - ~ foo: 条目作为一种对象(文件、目录或链接)纳入版本控制， 但是已经被另一种对
    像替代。
  如果传递一个路径给svn status，则只会显示该路径下的信息。
  svn status有一个--verbose(-v)选项,可以显示工作拷贝中的所有条目，即时是没有改
  变过的。并且显示的信息会更多。
  $ svn status -u -v，这个命令会联系服务端的版本库，会为工作拷贝内已经过时的数
  据添加新信息。如果发现输出中有被星号(*)标志的条目，则表示你在提交之前， 需要
  使用更新操作svn update得到被标志的条目的最新版本，否则说明该条目已经过时，版
  本库会拒绝你的提交。

- $ svn diff 或 $ svn di
  不带参数的该命令会显示你所做的修改,并输出统一区别格式(unified diff format)的
  区别信息。该格式和命令行中使用命令$ diff -u a.c b.c一样。

- $ svn revert
  是的，如果你diff发现某个文件修改错了，或者是不需要修改的，那么就可以利用这个
  命令来回退操作了。$ svn revert a.c即可。

/* 解决冲突(合并别人的修改) */
在提交之前，可以使用命令svn status -u(或者是svn update)来和服务端版本库通讯,来
预测冲突。 当冲突发生时，首先，subversion在更新时打印C标记，并且标记这个文件已
冲突；如果系统认为这个文件是可合并的，他会置入冲突标记，即在该文件中用特殊的横
线分开冲突的“两面”，这是可以看见的；最后，对于每个冲突的文件，subversion放置三
个额外的未版本化文件到你的工作拷贝：
- filename.mine 
  你更新前的文件，没有冲突标志，只是你最新更改的内容。如果subversion认为这个文
  件不可以合并，则该文件不会创建。
- filename.rOLDREV
  其中，文件后缀名中的OLDREV会被具体的版本号代替，比如a.c.r2。该文件是做更新操
  作之前BASE版本文件，就是你在上次更新之后未做修改的版本。 比你现在的filname文
  件还老。
- filename.rNEWREV
  文件名的后缀还是如上面一样。这是你的客户端从服务器刚刚收到的版本，对应版本库
  的HEAD版本。

如果是有冲突的话，subversion不会允许你提交有冲突的文件，直到你的三个临时文件被
删掉。如果提交，会输出一个提交失败的信息，并指出哪个文件有冲突。
  
如果碰到冲突，有三个选择：人工合并冲突、用三个中的某一个临时文件覆盖你的冲突文
件和使用svn revert filename 来放弃你做的本地修改。不管使用哪种方法，在解决冲突
之后，需要通过命令svn resovled  filename让subversion知道，这样会自动删除三个临
时文件，系统就会认为这个文件不在冲突状态了。
- 手工合并冲突
  在更新后的冲突文件中，已经被标记了冲突标志，找到冲突标志后，了解冲突内容，和
  另一个修改者进行沟通之后，进行相应的修改，并删除冲突标志(记得要删除哪些<, =
  和<组成的字符标志)，然后运行命令svn resolved filename，然后提交即可。 你可以
  参考三个临时文件来帮助你解决冲突。
- 如果你不用你的修改，直接用来自版本库最新的修改，则只需要直接用最新的临时文件
  file.rNEWREV覆盖你自己的本地文件即可。
- 如果你决定取消自己做的修改，并重新编辑，可以使用命令svn revert filename。 之
  后，不再需要运行svn resovled了。

/* 提交修改 */
命令svn commit发送所有的修改到版本库。当你提交时，你需要提供一些描述修改的日志
信息，你的这些信息会附到这个修订版上。如果信息很简短，可以直接在命令行中使用该
命令的一个参数选项--messag(或-m)，例如：
  $ svn commit -m "Corrected number of cheese slices."
同样的，你可以指定一个文件作为日志信息，使用--file(-F)选项，例如:
  $ svn commit -F logmsg

如果在提交命令中没有指定-m或者-F选项，subversion会自动启动你在配置文件中指定的
编辑器来让你输入日志信息。
如果在提交是发现有过期的错误，则需要运行svn update来处理所有的合并和冲突，然后
在尝试提交。

如前面所说的那样，你进行了提交之后，服务端版本库的版本修订号会增加1， 但是你的
本地工作拷贝的版本号是不变的，只有运行update才会下载最新的修改，使你的工作拷贝
被标记为最新的版本号。

/* 查看历史 */
subversion保存了项目的历史上的所有的修改的信息，你可以根据时间或者版本号来提取
一个相应的过去的版本，也可以只查看对应的修改历史。以下的命令就可以完成该功能。

- $ svn log
  该命令不带选项参数时，会显示所有的历史信息，包括：修改者、修订版本号、修改日
  期和时间以及日志信息。信息的排列顺序是按时间逆序排列的，即从新到老。
  如果希望查看特定顺序的一段修订版本或特定某个版本，使用参数--revision(-r)。例
  如：$ svn log -r 5:19，为查看版本号从5到9的顺序的历史信息；$ svn log -r 19:5
  ，为查看版本号从19到5的顺序的历史信息；$ svn log -r 8，为只查看版本号为8的历
  史信息。
  你也可以查看单个文件或目录的日志历史，例如：$ svn log foo.c。
  如果希望得到更多详细的信息，加上--verbose(-v)选项。

- $ svn diff
  该命令可以完成三个功能，检查本地修改、比较工作拷贝与版本库和比较版本库与版本
  库。其中，检查本地修改在检查修改时已经说明过了，不带任何参数调用时即可实现此
  功能，并且此时是不与版本库进行通信的。
  如果传递一个--revision(-r)参数，你当前的工作拷贝会与你指定的版本比较。例如：
  $ svn diff -r 3 foo.c。
  如果通过--revision(-r)传递两个通过冒号分开的版本号，会对这两个版本进行比较。
  例如：$ svn diff -r 2:3 foo.c。
  另外一个参数选项--change(-c)可以用来比较前一个修订版。例如：$ svn diff -c 3 
  a.c，该命令会自动比较-c指定的参数的版本号3以及该版本的前一版本号2。

- $ svn cat
  如果你只是想要看看一个过去的版本，使用svn cat即可。例如：$ svn cat -r 2 a.c，
  就可以输出版本号为2的a.c文件的整个内容，使用重定向就可以输出到一个文件了。另
  外，这个命令的执行可以是没有工作拷贝的情况下执行的。

- $ svn export
  该命令和checkout不同，该命令导出版本库，但是没有.svn目录。同样，和update和c-
  heckout一样，可以通过选项--revision(-r)来指定需要导出的版本号。

/* 属性操作 */
- $ svn propdel 或 $ svn pd
  删除一个属性。
- $ svn propedit 或 $ svn pe
  编辑一个属性。
- $ svn propget 或 $ svn pg
  取得一个属性的值。
- $ svn proplist 或 $ svn pl
  查看工作拷贝的一个条目的属性。
- $ svn propset 或 $ svn ps
  设置条目的一个属性。

/* 定制subversion */
每个客户端的配置目录位于home下的.subversion。具体各个参数意义，参考svnbook。

/*------------------------------ 分割线 -----------------------------------*/

/*** 分支 ***/
/*
 * 太复杂了...，所以这里没有详细讨论，可以跳过。
 * 如果真有需要，请仔细阅读svnbook
 */
/* 创建分支 */
有两种方式来创建一个分支:一种是先chech out一个工作拷贝，然后svn copy一个到本地
上，最后提交到服务端版本库；另一种则是直接操作服务端版本库，而不用像第一种方法
那样需要工作拷贝，例如：$ svn copy svn://armserver/repos/monitor/trunk  svn:/-
/armserver/monitor/branches/my_branch1 -m "Creating branch of monitor/trunk."。

/* 在分支上工作 */
现在你已经在版本库里建立了一个分支了，你可以取出一个新的工作拷贝来使用。使用命
令：$ svn checkout svn://armserver/repos/monitor/branches/my_branch1。此时你对
这个工作拷贝提交的修改和trunk是无关的了，修改的是版本库中的my_branch1。

/* 从主线上复制修改 */
在你的分支工作拷贝目录里执行命令$ svn merge -c 344 svn://armserver/repos/moni-
tor/trunk。-c后面指定要合并的主线上的版本号。

从主线得到修改之后，你应该审查该修改来确定它们工作正常。如果有冲突，则使用标准
过程来解决这种状态，如果像放弃，使用svn revert放弃该修改。

当你审查合并结果之后，使用svn commit提交修改，此时，修改已经合并到了分支上了。

/* 找回删除的文件 */
首先，使用svn log查看是在那个版本号里，该文件，假设为a.c，被删除了。假设是在版
本号80里被删除了。这时，你应该知道，应该要到版本号79里去取回该文件。因此使用命
令svn copy -r 79 svn://armserver/repos/monitor/a.c。这样便在本地的工作拷贝里有
了该文件，在通过svn commit该文件重新添加到服务端的版本库里了。

/*------------------------------ 分割线 -----------------------------------*/

/*** 版本库管理 ***/
/* 创建版本库 */
在服务器上进行$ svnadmin create /path/to/repos操作，具体如下。
首先进入~/work/svn/目录下,然后使用命令：
  $ mkdir demo_repos
新建一个目录作为版本库所在的目录，然后使用创建命令：
  $ svnadmin create demo_repos
则demo_repos下有了一些版本库系统文件和目录。此时，demo_repos即为项目版本库的根
目录，所有该项目的文件和目录都是在该目录进行管理。

此时创建的在服务端的只是一个空的版本库，里面是没有任何内容的(从客户端来看)。此
时需要导入些文件进入版本库。假设你在客户端本地上已经写好了你的项目的一些雏形的
文件和相应的目录，并且该目录下全部是你想要导入进版本库的文件和目录，而没有包含
那些诸如编译目标文件等不希望被版本化的文件。subversion提供了两种方法来导入，一
种是使用svn import，一种是使用svn add。

/* 用户认证 */
在导入之前，首先进行对版本库进行一些配置。

这里使用的是最简单的自定义svnserver作为服务端。 所以，如果要建立一个用户，并且
使能密码，首先修改版本库目录下conf/svnserve.conf，去掉anon-access, auth-acces-
s以及password-db前面的注释符，然后在conf目录下的文件passwd中按照格式添加用户名
以及对应的密码。


- svn import
  svn improt是将为版本化文件导入版本库的最快方法，会根据需要创建中间目录。该命
  令不需要一个工作拷贝，你的文件会直接提交到版本库，这通常用在你希望将一组文件
  加入到版本库时。因此，这个对于创建了一个新的空版本库后，导入具有雏形的本地项
  目是十分有用的。这边假定一个项目占据一个版本库。
  假设你在本地已经有了项目源文件以及其他资料文件和目录，则你首先需要调整一个目
  录布局。 建立一个demo目录，然后创建三个子目录：branches、tags和trunk，这样规
  划比较推荐。 然后将源码以及想要版本化的条目放置在主开发线的目录trunk下，保持
  branches和tags目录为空。然后执行命令导入数据：
    $ svn import demo svn://armserver/home/arm/work/svn/demo_repos
  该命令在服务端svn目录下建立项目根目录demo_repos， demo_repos目录下即包括了三
  个目录，为trunk、branches和tags，效果类似与cp demo demo_repos。三个子目录tr-
  unk，branches和tags，分别用来管理主线开发版本、分支开发版本和标签版本。
  这样导入了相应的文件和目录之后，接下来需要建立一个本地的工作拷贝，以后的工作
  就在该工作拷贝下进行了。使用命令：
    $ svn co svn://armserver/home/arm/work/svn/demo_repos/trunk demo_l
  该命令会在当前目录下新建一个目录demo_l，里面的文件即为远程trunk/目录下的文件
  了，效果类似于cp trunk demo_l。

- svn add
  该命令可以用来导入数据，不过要求是先在本地有一个工作拷贝，然后在工作拷贝内使
  用命令svn add添加文件和目录，再提交。 这种方法比较繁琐，一般用在平常项目开发
  中，而不会用在版本库建立中。 也可以直接以URL为操作目标在服务端之间添加条目，
  这会引起一个立即提交。

对于版本库里其他的文件系统操作，均可以在客户端使用add、mkdir、rm等来完成，只不
过后面的目标都是URL指定。

在初始化的将项目文件和目录导入到版本库之后，管理者(或者客户端使用者)还有一些工
作要做，可能包括：忽略ignore、关键字替换等。当然，不做这些工作不会影响版本库的
正常工作，但是这些设定会让你的版本库工作地更优雅。

/* 忽略不需要版本化的文件 */
在任何工作拷贝中，将版本化文件和目录与没有也不准备版本化的文件分开会是非常常见
的情况，包括文本编辑器的备份文件、代码编译过程中的中间文件，甚至是最终的可执行
文件。 在使用svn add或svn import时，因为是递归调用，所以可能会添加这些不需要版
本化的文件或目录。

subversion提供两种忽略实现，一种是修改subversion的运行配置文件，这样所有的操作
都会利用这个配置；另一种是使用目录属性支持，即svn:ignore。配置文件最好是用于全
局都不希望版本化的，比如vim的备份文件*.swp(也就是说支持正则表达式)。而对与具体
项目来说，最好还是使用目录属性来实现忽略。其中目录属性的忽略只应用到其设置的目
录，而不会应用到其子目录上。

添加该目录属性的命令为:$ svn propset svn:ignore -F .ignorefile，指定一个文件为
目录忽略的内容，文件内一行一个文件模式。这样执行该命令的当前目录的这个目录属性
就被添加了。或者使用$ svn propedit svn:ignore来直接编辑(推荐这种方法)：
    $ svn propedit svn:ignore .
该命令即对当期目录设置该属性。在打开的默认编辑器中，每行设置一个需要忽略的文件
类型，例如：tags, *.o, *.swp。
 

如果需要查看被忽略的文件，可以使用--no-ignore选项：svn status --no-ignore。 被
标记为'I'的即是被忽略的文件。同样，add以及import命令也可以用该选项来忽略忽略。

/* 关键字替换 */
对于subversion来说，一些版本信息是不需要手动添加的，subversion提供了关键字替换
这个功能，用来自动更新一些有用的字符串，包括：
- Date, LastChangedDate
  文件最后一次在版本库修改的日期。
- Revision, Rev, LastChangedRevision
  文件最后一次修改的修订版本号。
- Author, LastChangedBy
  最后一个修改这个文件的用户。
- HeadURL, URL
  这个文件在版本库的完全URL
- Id
  是其他关键字的一个压缩组合。
除了在文本中添加相应的关键字之外，例如: $LastChangedDate $，你还需要在该文本文
件的文件属性里设置，以告知subversion你希望系统替换该关键字。该设置文件的文件属
性的命令为：$ svn propset svn:keywords "Date Author" a.c。这里设置了两个关键字
的替换，一个为Date，一个为Author，针对的是文件a.c。 这样在提交属性修改之后，你
就可以在文件的关键字位置看到，该关键字已经被扩展为了具体的版本信息字符串。在源
码里，可以将这些关键字放在注释里，或者放到打印字符串中，对于了解程序的版本信息
十分方便。

不过需要注意的是，关键字"Rev"经常会将新用户迷惑。 自从版本库有了单独的全局增长
的修订版本号码，许多人认为Rev关键字是放映修订版本号码的，但实际上Rev是含有该关
键字的文件最后修改的修订版本，而不是最后更新的，即不是所谓的GlobalRev。

那么为了得到全局修订版本号，subversion提供了一个工具svnversion。它会遍历你的工
作拷贝，然后输出它发现的修订版本。你可以使用这个程序，外加一些工具，将修订版本
信息嵌入到你的指定文件中。

下面给出两种方法。两种方法都需要一些共同的准备工作。需要创建一个存放版本信息的
文件，这里为version.h。并且项目的目录结构如下所示：
.
|-- Makefile
|-- config/
|-- doc/
|-- res/
|-- sh/
`-- src/
    |--version.h
    |-- ....
    `-- Makefile

/* 方法一 */
首先在sh目录下创建一个shell脚本，svnversion.sh，内容如下：

#!/bin/sh
#自动添加subversion的全局版本信息
#以及其他需要的信息到指定文件中

#切换为英文语言环境
LANG=en_US.UTF-8
VERFILE=./src/version.h

svn_ver=`svnversion`
svn_date=`date`
sys_info=`uname -rsnm`
sys_user=`whoami`

echo "#define SVNREV \"$svn_ver\"" > $VERFILE
echo "#define SVNUSER \"$sys_user\"" >> $VERFILE
echo "#define SVNDATE \"$svn_date\"" >> $VERFILE
echo "#define SVNINFO \"$sys_info\"" >> $VERFILE

执行这个脚本，会将你所想要输出的信息作为字符串宏输出到指定文件中。

为了能够在每次更新版本库后能够自动执行该脚本，以便自动更新版本号信息，还需要修
改项目顶层目录下的Makefile，增加一个目标，如下：

up:
	svn up
	./sh/svnversion.sh

这要求以前使用$svn up进行update版本库，如今要使用$make up来进行。 $make up首先
执行svn up，更新版本库，然后执行上述的脚本，将更新后的版本库的相关信息写入到指
定文件中。这样便完成了信息更新的自动化，并且版本号是由svnversion得出的全局版本
号。

/* 方法二 */
首先，针对需要记录版本信息的文件version.h设置好关键字字符串并且使
用svn设置好关键字替换属性，如上所述。

然后修改顶层的Makefile文件，添加一个目标，如下：

ci:
	echo "#define a" >> ./src/version.h
	svn ci

这要求从前使用$svn ci进行提交，如今要使用$make ci来进行。 $make ci首先添加一行
无效的宏定义到指定文件，以便自动对文件进行修改，然后执行提交命令。因为每次提交
前都对指定文件进行了自动修改，因此每次提交后都会进行版本信息关键字替换，保持为
最新的全局版本号。

两种方法都是对version.h进行添加版本信息。只要包含version.h即可进行调用。两种方
法都是需要用户添加Makefile一个新目标来代替原来的svn ci或svn up。这个需要用户自
己记住。

第一种方法，采取了由用户自己提取信息，然后添加为字符串宏来进行调用。优点是用户
可以添加很多其他信息到文件中；缺点是除了svnversion之外，其他信息的获取都是有用
户自己获取的。

第二种方法，采取了自动修改需要进行关键字替换的文件。优点是使用的是subversion提
供的关键字替换机制；缺点是，每次执行会给指定文件添加额外的无效宏定义，需要用户
自己定期删除。

注意，如果要加入关键字替换字符串以及属性的文件的编码不是UTF-8，则里面的非英文
字符可能会被弄成乱码。

/* 管理版本库 */
- svnadmin
  - svnadmin setlog
    如果管理员想要修改日志信息，则可以使用该命令。这个命令从指定的文件中读取信
    息，取代版本库中某个修订版本的日志信息(svn:log属性)。例如：
    $ echo "this is new log message" > newlog.txt
    $ svnadmin setlog demo_repos newlog.txt -r 388
    
  - svnadmin lstxns demo_repos
    该命令列出当前的事务名。该命令一行一个事务代号，如果将事务代号作为svnlook 
    -t的参数，就可以获得关于该事务的详细信息，进行判断是否将这个事务安全的删除
    。如果可以删除，只需将事务代号作为svnadmin rmtxns的参数即可。例如：$ svna-
    dmin rmtxns demo_repos a45。如果需要将lstxns的输出都删除，则可以将该命令的
    输出作为删除命令的输入：$ svnadmin rmtxns demo_repos `svnadmin lstxns dem-
    o_repos`。这个命令一般用来清楚异常事务(比如客户端粗暴结束操作、 操作过程中
    出现网络故障等),因此在清理之前，最好暂时关闭版本库和客户端的连接，防止正常
    的事务进入版本库。

  - svnadmin dump demo_repos > dumpfile, svnadmin load newrepos < dumpfile，
    svnadmin dump demo_repos | svnadmin load newrepos
    以上的命令是用来对subversion版本库进行转储数据的。

  - svnadmin hotcopy /path/to/repos /path/to/repos-backup
    该命令实现来完全备份，并且解决了热拷贝中的细节问题。

- svnlook
  svnlook是用来查看版本库中不同的修订版本和事务。 是一个“只读”的工具，可以使用
  该命令来诊断。如果没有使用选项，则会检查版本库最新的修订版本，即HEAD。也可以
  通过--revision(-r)和--transaction(-t)选项来指定要查看的修订版本号或事务。 例
  如：$ svnlook info demo_repos，$ svnlook info demo_repos -r 19。另外还有一个
  选项的使用:$ svnlook youngest demo_repos，只会打印出版本库的最新修订版本号。

- svndumpfilter
  用于在数据转储过程中，提取或者过滤掉指定的条目。

- svnsync
  用于版本库的复制。用于转移或者做镜像版本库。

/*------------------------------ 分割线 -----------------------------------*/

/* tips */
如果你不小心删除了.svn目录，先不要做其他操作，然后使用普通的删除命令删除包含的
目录，在父目录运行svn update，这样subversion客户端会重新下载你删除的目录，并包
含新的.svn。

在项目中尽量不要使用软链接。

一般提交之前需要update一下，以检查有没有冲突。如果有冲突，是不允许你提交有冲突
的文件。

如果在svn status时(事实上，每次提交之前应该做这个动作)发现有文件被标记了L， 则
只需要执行命令svn cleaup即可，解除锁定。

获得一个工作拷贝之后，通过svn commit来提交修改，通过svn update来接收修改，通过
svn status检查工作拷贝状态。

你可以通过关键字、日期以及版本号来获得对应的版本库修订号。
对于关键字，可以通过-r指定。例如svn log -r HEAD, svn log -r BASE:HEAD。
- HEAD 版本库中最新的版本。
- BASE 工作拷贝中的未修改的版本，即update后的版本。
- COMMITTED 项目最近修改的修订版本，与BASE相同或更早。
- PREV 一个项目最后修改版本之前的那个版本，即COMMITTED-1。
对于时间，同样使用-r来指定。例如svn log -r {2006-11-20}，这里没有指定具体时间，
只有日期，你也可以指定时间，{2006-11-20T15:30}，值得注意的是，如果没有指定时间
的话，比如2006-11-20，则取得的是19号版本，因为系统假定的时间是00:00:00，所以在
20号找不到任何版本。你可以使用时间段来取得版本号，-r {2006-11-20}:{2006-11-29}

svn lock用来锁定版本库中的某个文件。 $ svn lock a.jpc -m "my lock"。-m说明锁定
的原因。

在对版本库进行操作的URL的路径名中如果包含来空格等字符，需要使用" "来包含整个版
本库的URL，以便能够正确的定位版本库。

如果嫌每次输入URL太长，你可以在自己的shell设置一个环境变量来代替。例如，服务器
上的svn的版本库一般都放在/home/arm/work/svn目录下，因此你可以在~/.bashrc文件里
添加语句：export SVNPATH=home/arm/work/svn。这样，当你输入的URL的格式如下时：
  svn list svn://armserver/$SVNPATH/demo_repos
实际的URL为：
  svn list svn://armserver/home/arm/work/svn/demo_repos
当然，定义怎么样的环境变量取决你自己。

