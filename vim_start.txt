Index and Tags：
==============================================================================
-|Setup|
-|Introduction|
-|Preparation|
-|Mode|
  -|IN|CN|VN|RN|
  -|NI|NC|NV|NR|
-|FileOperation|
   -|OpenFile|ShiftTab|ShiftWindow|
   -|SaveFile|Quit|
-|NavigationJump|
  -|Navigation|Jump|ShiftPage|
-|BasicEdit|
  -|DeleteText|MoveText|VisualMode|UndoRedo|
-|CombineOperation|
  -|CountCmd|CmdMotion|RangeCmd|
  -|Record|record|
-|SearchSubstitute|
  -|Search|search|Substitute|
-|AboutProgramming|
  -|CommonCmd|SystemCmd|
  -|ColorScheme|SyntaxHighlight|LineNumber|Indent|ChangeIndent|
  -|RepeatChange|Map|AutoCompletion|Completion|
  -|folding|Man|ascii|ManageProject|
  -|RunCommand|FileEncoding|
  -|Plugin|Taglist|ctags|TagsJump|quickfix|
-|Summary|
-|Reference|
-|VimVersion|

本文档介绍基本的Vim操作，用以文本的编辑，然后特别再介绍vim在编写C语言时的应用。
限于本人水平有限已经本文只是入门介绍，很多高级用法和特性并没有在文中。同样，可
以用基本指令完成的、对应的复杂难记的不讲。很多有同样功能的快捷键，可能只会讲述
其中比较简单和易于记忆的那种。同时，为了便于记忆，会给出我自己认为的各个快捷键
的缩写，方便记忆。

*Setup*
==============================================================================
该文档格式采用了Vim的帮助文档格式，主要为了高亮显示以及跳转。 该格式使用特殊的
字符来表示特定格式和链接，也算一种标记语言吧。 只有当vim识别文档类型为help时，
vim才会辨别和解析这些字符。因此请使用vim打开进行阅读。

有两种方法让vim识别该文档为help：手动和自动。

1. 手动。在使用vim打开文件后输入以下命令，手动设置文件类型为help: >

	:set filetype=help

2. 自动。本文最后通过modeline方式进行文件类型的自动设置。 如果没有生效，可能是
   因为没有使能modeline功能。要使能该功能，请在配置文件中加入这两个配置: >

	set modeline
	set modelines=5

其中modelines后面当值为非0的正数即可。更多关于modeline的设置，请查看帮助: >

	:help modeline
	:help modelines

通过这些设置，即可高亮显示文档了。如果需要能够进行跳转，输入以下命令生成跳转符
号的tag文件: >

	:helptags .

即可在当前目录下声称该文档的tags文件，用于在各个标签之间跳转。


*Introduction*
==============================================================================
我初次转入Linux下进行开发的时候，第一个念头就是找一个编程软件， 然后就可以在该
软件提供的环境下进行软件的编写、编译和调试。这种想法估计大部分人，特别是没有接
触过非Windows开发的人，都会有的，都想着去寻找这么个“Visual Studio”。

事实上，Linux(或者Unix-like)系统下确实有这样的IDE存在，比如Eclipse、netbeans、
Code::Block、Kdevelop等等。这些IDE有着不弱于VS的界面和功能，语法高亮、自动缩进
、代码补齐、语法折叠等功能都具有，并且有出色的扩展性，比如Eclipse。一个IDE便就
是软件开发所需要的一切了。

然而，这些IDE的工作只是让你输入文本来编写代码以及管理项目工程。 实际的代码编译
则是由IDE调用外部编译器程序，比如gcc、armcc，来完成，调试则调用gdb。这样看来，
这些IDE实际做的工作也不多的。

简单来说，一个静态语言程序的生成过程经过了以下几个步骤：

- 编写代码，得到源文件；
- 编译，得到目标文件；
- 链接，得到最终可执行文件。

对于Linux下的C语言来说，第二步使用gcc完成，第三步使用ld完成， 而第一步本质上只
是单纯的文本编辑工作，所以才有那么句话：高手都使用记事本写程序的。

这个笑话(如果可以认为是笑话的话)当然是在Windows下产生的。 但这也说明了，如果只
是编写代码，是不需要VS这种重量级工具的，因为记事本就可以完成代码的编写。而程序
的编译、调试，都是由另外的工具完成。只不过这些工具被IDE的GUI界面所屏蔽了，你点
击了编译图标(make, build, compile之类的)， 其实就是告诉IDE去调用设置好的编译器
使用设置好的编译参数进行编译工作。

如果有使用过Turbo C的读者应该就可以了解， 如何在Windows的控制台(CMD)下使用命令
行进行程序的开发。使用记事本写代码，然后使用命令行对源码进行编译，生成可执行文
件。

Linux下进行软件开发也是如此(C是如此，其他语言就不一定了)。 编译通常用gcc，项目
管理使用make，调试使用gdb，而用于源代码编写的工具的选择就多了。 Unix的一个哲学
是：每个工具专注于完成一件事，并且很好地完成；然后将多个工具联合搭配使用，来完
成一个复杂的任务。这样的好处，除了能够清晰地将复杂任务分解为几个阶段来完成，并
可以配合脚本部署自动化，还使得各个阶段的工具都是可替换的，用户可以自主选择熟悉
或者高效的工具。另一方面，用户一旦熟悉了某个工具，在任何需要相关功能的场合，就
可以直接使用该工具，而不需要重新学习另外工具软件。这样可以重复利用已有知识、节
省学习时间。

在软件开发过程中，后几个阶段的工具选择一般争议不大，但是对于代码编写，即编辑器
的选择，选择则有很多。有人说，世上的程序员分三种，使用Emacs的，使用Vim的，以及
使用其他编辑器的(诸如notepad++、UltraEdit、gedit、nano等)。

这里就不去多提及Emacs了， 从久远的时代开始，就一直有着“谁才是史上最强编辑器”的
圣战上演。但是根据上面提到的Unix上的工具哲学来看，Vim无疑更符合，而Emacs更像是
一个“操作系统”，可以在里面做任何事情，听音乐、画图、上网，泡咖啡...

摘自维基百科:

"""
Vim是从vi发展出来的一个文本编辑器。 代码补完、编译及错误跳转等方便编程的功能特
别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。

Vim的第一个版本由Bram Moolenaar在1991年发布。 最初的简称是Vi IMitation，随着功
能的不断增加，正式名称改成了Vi IMproved。 现在是在开放源代码方式下发行的自由软
件。

Bram Moolenaar在80年代末购入他的Amiga计算机时，  Amiga上还没有他最常用的编辑器
vi。Bram从一个开源的vi复制Stevie开始，开发了Vim的1.0版本。最初的目标只是完全复
制vi的功能，那个时候的Vim是Vi IMitation(模拟)的简称。

1991年Vim 1.14版被"Fred Fish Disk #591"这个Amiga用的免费软体集所收录了。1992年
1.22版本的Vim被移植到了Unix和MS-DOS上。从那个时候开始，Vim的全名就变成Vi IMpr-
oved(改良)了。

在这之后，Vim加入了不计其数的新功能。做为第一个里程碑的是1994年的3.0版本加入了
多视窗编辑模式(分割视窗)。 从那之后，同一萤幕可以显示的Vim编辑文件数可以不止一
个了。1996年发布的Vim 4.0是第一个利用图型接口(GUI)的版本。1998年5.0版本的Vim加
入了highlight(语法高亮)功能。2001年的Vim 6.0版本加入了代码折叠、插件、多国语言
支持、垂直分割视窗等功能。2006年5月发布的Vim 7.0版更加入了拼字检查、上下文相关
补全，标签页编辑等新功能。2008年8月发布的Vim 7.2， 合并了Vim 7.1以来的所有修正
补丁，并且加入了脚本的浮点数支持。现在最新的版本是2010年8月发布的Vim 7.3，这个
版本除了包含最新修正的补丁之外， 还加入了“永久撤销”、“Blowfish算法加密”、“文本
隐藏”和“Lua以及Python3的接口” 等新功能。
"""

关于Vim的历史以及NB之处，可以查看参考资料。

如同前面所说的，一旦掌握了Vim，在任何需要编辑文本的应用场合，你都可以使用Vim来
完成。并且借助Vim的强大，你可以快速、高效地完成。 例如在mutt中编写邮件、修改系
统配置文件等。 同时，Linux下的很多软件的操作方式也深受Vim的影响，比如man手册的
浏览方式、shell的命令输入方式、top的操作等等。这些操作的统一性，对于用户来说感
觉非常顺手和舒适。

此外，Vim是跨平台的，而且跨的还蛮远的， 从Linux、Unix、BSD到Windows、MacOS，甚
至Android上也有了。

对于C软件开发来说，Vim + make + gcc + gdb就足够搭建整个开发环境了。 这也符合了
Unix下的工具链哲学，同时也使得开发流程简单清晰明了。

回归正题。本文档主要做一个Vim的简单入门，并介绍在Linux下如何使用Vim进行C语言的
代码编写和项目工程管理。所有的一切都围绕着Vim来进行，在必要时会提及其他的shell
工具。 当然，该文档的大部分内容也适用于将Vim当作普通的非代码编辑器或者其他语言
的编辑器使用的读者。

目前编写该文档时所使用的工作环境是MacOS 10.10.4，homebrew安装的Vim7.3，Vim的编
译选项和具体版本信息可以查看文档最后给出的信息|VimVersion|。 Vim使用的图形界面
是ncurse，即直接在终端下输入命令: >

    $ vim

控制台下的Vim，和gVim等其他图形界面有细微差别。并且文档假设读者已经熟悉Linux下
的命令行操作。此外，文档要求所有操作只通过键盘进行，且只在主键盘区进行，没有鼠
标和键盘其他区域什么事儿。

文档中命令如果以'$'字符开头，表示在终端下输入的命令。如果以':'字符开头，表示在
vim内部输入的命令。


*Preparation*
==============================================================================
对于初次使用Vim的人，常常会发现对Vim无从下手。因为在打开之后，按下按键，屏幕上
并没有出现相应的字符输入。这就会让人觉得，“什么东西啊？”、“好难啊，不学了！”。
我在接触Linux之初，久仰Vim的盛名，但是碰到这种情况然后退却了。 在使用gedit半年
之后，狠下心学了一周之后，如今再也离不开Vim了。

Vim的学习曲线是很陡峭的，很多人往往一开始遇到困难就止步了， 转而使用那些不需学
习即可使用的编辑器。但是我要说的是，不需一周，在掌握基本的操作之后，你就可以无
障碍地使用它了。这时你就可以把Vim当作普通的编辑器来使用。在后续使用Vim过程中，
再慢慢一点一点的熟悉Vim的模式、快捷键以及高级用法，就能使用Vim来高效地完成各种
文本编辑工作了，包括写代码。 这时，你就能体会到Vim的强大，也会像我一样，再也离
不开它了。

在正式开始介绍Vim之前，不得不提一下它的帮助手册。Vim的帮助手册估计是世上最好的
软件帮助文档之一。 Vim里所有的快捷键、命令、模式、脚本等等的说明都可以在里面找
到，而且可以直接在Vim中查询，编排合理，跳转方便。如果安装好了Vim之后(Vim的安装
就不说了吧，直接使用apt-get安装或者下载源码自己make)，直接在终端下输入命令: >

    $ vimtutor

来查看一个针对初学者的30分钟快速入门教程。作为拥有诸多拥趸的Vim还有中文教程：

    http://vimcdoc.sourceforge.net/

在该网址中能够找到Vim帮助文档的中文版链接。

最权威、全面和详细的关于Vim的解答，就是自带的帮助文档了。 限于我水平，如果本文
档中的介绍和帮助文档有出入，毫不犹豫，相信帮助文档吧。另外，如果本文档和读者所
看的其他Vim的文章对某些问题有所出入的话，只能说对于我的工作环境下(包括版本、配
置等)，这些是适用的，最后正确与否当然还是要靠读者在自己的环境下实践证明了。

下面就正式开始吧!


*Mode*
==============================================================================
前面说过，很多初学者在打开Vim之后， 按下键盘后并没有在屏幕上看到任何的文本输入
发生。这是因为Vim的初始模式是普通模式，而在该模式下是不能进行文本输入。

Vim是一个多模式编辑器。 这个独特的设计会让很多初学者感到迷惑，这也陡峭的学习曲
线的一部分。但也正是因为如此Vim才是强大的。

Vim具有五种基本模式和六种派生模式。 其实初学者不需要掌握所有这些模式，目前只需
要知道基本的模式即可，其他的模式可以在日后的使用中慢慢了解、掌握。

五种基本模式是：普通模式(normal mode)、插入模式(insert mode)、命令模式(command 
mode)、可视模式(visual mode)和替换模式(replace mode)。

普通模式是Vim打开之后的初始模式以及使用中的默认模式。 在该模式下，用户执行一般
的编辑命令。说是命令可能有点严重，其实就是输入各种快捷键来实现各种功能。也就是
说，在该模式下的键盘输入是被Vim当作快捷键对待的，而不是文字录入。

普通模式下的各种快捷键操作构成了Vim的强大编辑功能， 当然也造成了对该各种快捷键
进行记忆的必要性。啊，又是一个陡峭的小山坡，不过没关系，只需记住一些常用的命令
先。先用起Vim就可以了，复杂的以后边用边学吧。

插入模式则是其他编辑器的默认状态。 进入插入模式之后，Vim就和一般的编辑器没有区
别了，你完全可以把Vim当作你常用的编辑器来使用。 在光标处键入你想录入的文字，这
样应该让你找回熟悉的感觉了吧。想要换个地方输入？你会习惯性的拿起鼠标，然后点击
到目标位置，让光标移动到那里后，然后继续输入吧... 难道忘了吗？本文档里是不使用
鼠标的，全部的操作都是由键盘完成的。好吧，你改用方向键来移动光标... 这样虽然可
以，但是仍然不够高效。那如何高效地完成呢，往下看就知道了。
>
实际上，如果在终端下输入: >

    $ evim

将会启动一个GUI版本的Vim，会一直停留在插入模式下。 这时Vim就表现得像个一般的编
辑器了，用户只能通过鼠标、菜单和键盘对文本进行各种操作。

命令模式和插入模式一样，也是一般编辑器都有的模式。你可能会感到惊讶，记事本也有
命令模式，怎么从来不知道呢？事实上，当你在记事本里按下CTRL-s进行保存时，便是进
入了命令模式，并执行保存命令；在你点击菜单里的保存时，也是如此。只不过一般编辑
器的命令模式只是暂时的进入、执行，结束后又立刻退回到了插入模式，以致你没有察觉
到。 Vim的命令模式却是显式地告诉你，当前就是在命令模式下，你可以输入命令，简单
的或复杂的，来完成相应的任务。

可视模式主要用于选择文本区域，然后将一些操作作用到选中的文本区域上。该模式下被
选中的区域会被高亮显示，可能因为这样所以取了可视这么个名字吧。我估计该模式主要
目的是用于替代鼠标来选择文本的，这样就可以不用鼠标、手不离键盘地选择文本了。当
然发展到后面，可视模式下能做的事情已经远远超过了鼠标能做的事情。

替换模式，顾名思义，就是用于替换的。读者在使用word时会发现，如果按下“insert”按
键后，你所输入的新文本会直接覆盖掉以前的文本，而不会像普通情况下将已有文本往后
推以空出空间放置新文本。这便是替换模式了。在Vim中也存在着这样的模式。

编辑器一个时刻只能处于一种模式下，也就是说模式之间存在着切换。模式之间的切换如
下图所示： >

                             NI           NC
             Insert Mode <--------+  +---------> Command Mode
                      |           |  |           │
                  IN  |           |  |           │ CN
                      +--------> Normal <--------+
                      +--------> Mode   <--------+
                  VN  |           |  |           | RN
                      |           |  |           |
             Visual Mode <--------+  +---------> Replace Mode
                             NV           NR

上图中的NI、NC、IN、CN、VN、RN、NV和NR表示模式之间进行切换所执行的操作。NI表示
Normal to Insert，其他的操作名称类似。

从上图中可以看出，普通模式为Vim的默认模式。 一方面，大部分的操作都需要在普通模
式下通过快捷键完成；另一方面，一种非普通模式要进入到另一种非普通模式，都需要先
进入到普通模式，再进行切换。 实际上，在使用Vim时，除了特别操作和录入文字，应该
一直处于普通模式下。如果不进行其他操作，就让自己待在普通模式下吧。

在文档后面的介绍里，如果没有特别说明当下处于哪种模式的话，都指的是在普通模式下
进行操作。

*IN* , *CN* , *VN* , *RN* 
-----------------------------
<esc>, CTRL-c, CTRL-[

首先介绍如何从各种非普通模式下如何回到普通模式，即上图中的IN、CN、RN和VN操作。
在其他模式下要回到普通模式，都有一样的方法：<esc>或CTRL-c或CTRL-[。 也就是说，
在其他模式下，只要输入这三个键中的一个，就会舍弃当下的状态而回到普通模式下了。

我个人比较常用CTRL-c，因为键程比较短，但是用多了小指头会比较累； <esc>也很好用
的，清楚明了、干净利落，但是键程较远，需要左手大范围跑动；CTRL-[，键程短，而且
常用也不累，不过需要两个手配合输入。至于选择那种方式，则见仁见智了。需要说明的
是，这个操作在Vim中使用的十分频繁、非常频繁，因此对该操作的选择要慎重考虑。 

我一般是CTRL-c和<esc>配合着使用：一开始用CTRL-c，手指累了就换成<esc>。在文档后
面的介绍里，统一用<esc>表示退回到普通模式操作。

除了使用<esc>，在某些模式下，完成了当前任务之后，会自动退回到普通模式。 在命令
模式下，输入完命令并键入回车之后，便会执行命令，而命令执行之后，便会自动从命令
模式退回到普通模式。在可视模式下，当前任务完成之后，也会自动回到普通模式。而对
于插入模式和替换模式， 如果不是显式地输入<esc>，则会一直处于文字录入状态：一个
是输入新的文字内容，一个则是替换已有的文字内容。

要进入插入模式，有很多快捷键，首先将常用的列出如下：

*NI*
-----------------------------
i, a, o, I, A, O, s, cw

i [insert] ([]中给出该快捷键或命令可能的缩写原单词，大部分为我的猜想，主要便于
记忆，后面也如此)操作，是在当前光标之前插入，即输入点位于光标之前。

按下该键之后，信息区(即界面下方状态栏的左侧，文档后面统一使用该词)会出现: >

    -- INSERT --

的字样，表明当前的模式是插入模式。什么，在普通模式下没看到类似的？因为普通模式
下没有。也就是说，当信息区没有任何模式提示时，表示当前处于普通模式下。

a [append] 则与i相反，是将输入点至于光标之后来进行输入。 o是在光标所在行下方新
启一行，并进入插入模式。

I和i相似，作用是在当前行的第一个非空白字符之前插入文本。所谓空白字符，如果熟悉
C里面字符操作的读者应该比较清楚，指的是tab(制表符)，空格等字符。A和a相似，读者
大概猜到了它的作用了，就是将输入点移动到在当前行的行尾来输入文本。O和o相似，在
当前行的上方新启一行输入文本。

Vim中类似i和I，a和A，o和O这样的，小写和大写执行的命令在某个意义上相仿，也是Vim
的特色之一，可以便于对快捷键的记忆。后面还会再碰到相似的快捷键。

s [substitute] 用来删除当前光标下的字符，然后进入到插入模式，以输入新的内容。

cw [change-word] 使用较少，和s相似，只不过删除的单位是单词。 首先删除由光标(包
括光标)开始的一个单词，然后进入插入模式，以便在该位置上输入新的单词。 组合起来
就是改变单词的意思啦。

*NC*
-----------------------------
:, /

进入命令模式可以键入:。键入:之后，最下方的状态栏会清空，并且在左下角出现一个冒
号，然后就等着你输入想要执行的命令了(更多实用命令后面介绍)。按下回车后便会执行
该命令。

命令执行完后便会回到普通模式。如果没有按下回车，而是进行了<esc>， 则舍弃当下命
令的输入，立即返回到普通模式下，状态栏也回复原样。

键入/，表示将要执行搜索功能。同样，最下方状态栏清空，并在左下角出现一个/号，然
后就等着你输入想要搜索的字符串了(关于如何搜索以及替换后面会介绍)。按下回车便会
执行搜索。

命令执行完后便会回到普通模式。 如果没有按下回车，而是进行了<esc>，则舍弃输入的
字符串，立即返回到普通模式下，状态栏也回复原状。

这里将搜索也归入命令模式，是因为在大部分的编辑器中，搜索其实也算是一种命令，并
且在编辑工作中使用非常频繁；而且下面会看到，搜索其实十分复杂的。

在这里先要抢先介绍的一个命令是help，使用方式如下(即进入到命令模式): >

    :help command

该命令可以打开Vim自带的帮助文档。如果在看本文档或者使用Vim过程中，对某些快捷键
或者主题不太清楚时，可以使用该命令查看相关主题的帮助。 例如对于对于:不清楚，则
执行命令: >

    :help :

即可查看到“命令行模式”的帮助了。

另外，:之后，使用向上方向键可以调出历史命令。 甚至输入:s之后，会对历史命令进行
过滤，只调出以s开头的历史命令。

文档中:后面表示，在Vim中执行某条命令。输入命令后需要键入回车<CR>以执行命令，文
中的命令介绍省略掉<CR>。

*NV*
-----------------------------
v, V, CTRL-v

三种进入方式提供了三种不同的文本选择方式。键入v之后，信息区出现: >

    -- VISUAL --

的字样，表示当前模式是普通的可视模式。键入V之后，信息区出现: >

    -- VISUAL LINE --

的字样，表示当前模式是可视行模式。键入CTRL-v之后，信息区出现: >

    -- VISUAL BLOCK --

的字样，表示当前模式是可视块模式。读者可以自己操作实践一下，根据高亮的文本区域
可以很清楚的看出三者的区别。至于具体的使用，后面再详细介绍。

*NR*
-----------------------------
r, R

键入r之后，信息区并没有出现类似"-- SUBSTITUTE --"的提示字样， 因为该键只是用于
替换光标所在的单个字符而已。反而会在提示区，即状态栏右侧位置、光标位置信息的左
侧，出现"r"的提示字样，这是表示将要执行的是一个组合操作。

如果你的Vim没有出现该提示，可能是因为默认设置没有使能。输入命令: >

    :set showcmd

即可显示出这个命令提示了。

所谓组合操作，即需要输入两个或多个按键才能完成的操作。一般在第一次输入后，提示
区会给出相应键的提示字样，表明该操作是组合操作，并等待你的第二次输入以及随后的
输入。当全部操作序列全部输入后，提示区的提示消失，表示输入完成。

输入r之后，会等待你的下一个输入字符。 在你输入一个字符后，该字符便会替换掉当前
光标下的那个字符。之后，便自动退回到了普通模式下。

而键入R之后，信息区会出现你所预料的字样: >

    -- REPLACE --

此时的行为表现就如同word里的替换模式一样。文字录入的过程中光标会指示你当前的输
入点在哪里。如果在键入过程中，你发现打错了一个字符，可以直接按后退键，光标会回
退，回退后的字符会变回替换前的字符。 输入过程中如果按下<esc>，则会保留已做的替
换修改，并返回到普通模式下。

关于模式的权威说明请查看Vim帮助文档，使用命令: >

    :help mode-switching

至此，常用模式以及之间的切换就介绍到此了。 相信读者对Vim的模式概念应该有较清晰
的认识了，后面就可以任意地使用这些模式来完成各种各样的任务吧。下面开始正式介绍
Vim的操作了。


*FileOperation* 
==============================================================================
前面介绍了如何在终端下打开Vim， 但是里面什么都没有，也就谈不上什么编辑操作。对
于编辑器来说，文件(特别是文本文件)是操作对象。 本小节就介绍如何在Vim中打开、保
存和退出文件。

*OpenFile*
--------------------------------------------------------------------
巧妇难为无米之炊。作为一个编辑器，总得有文本来编辑吧。 Vim有多种方式打开文件。
首先从命令行里直接打开文件开始，命令如下: >

    $ vim main.c

这样，Vim便会直接打开main.c文件。 至于命令行有多个文件名参数，或者如何一次打开
多个文件并且每个文件分别在一个标签页中打开，较为复杂，这里不介绍了...

如果当前已经打开了Vim，则执行命令: >

    :e main.c

e [edit] 即打开当前路径下所存在的main.c了。另外，在输入文件名时，可以通过tab键
来对文件名进行自动补齐，这和bash中一样。 不过个人感觉Vim的自动补齐更好一点，因
为Vim中会真正实现补齐； 而bash中如果有多个匹配时，只会给出提示，到最后还得自己
输入。自动补齐在后面许多的命令中都会有作用，包括对命令的补齐，对文件名补齐，对
路径的补齐等，后面就不特别提出了。

这时可能发生的意外情况有两个。

第一，当前的标签页内已经打开了一个文件在编辑， 并且修改了没保存(即标签页的文件
名前有个"+"号)，这时会在状态栏上给出一个错误信息，还是红色的哦。 你可以使用!强
制执行，即: >

      :e! main.c

将!放置在命令之后(不管参数)即可。 后果就是关闭原文件且修改没有保存，然后打开了
main.c。后面会介绍如何进行保存。

第二，当要打开的文件在路径下存在对应的swp文件时， 会给出提示信息，给出很多可选
操纵。提示给出的选择非常多，信息十分详细，这里就不赘述了。 至于swp文件，类似于
word里使用的临时文件，起到一个自动保存的作用。即你显式执行保存操作之前，所做的
操作都保存在这个临时文件中，这样就算突然断电或者系统崩溃，此前的编辑工作不会丢
失，可以使用swp文件进行恢复。swp文件在打开文件进行编辑时会自动创建；而在正常退
出之后，会自动清除。读者可以在终端下使用: >

      $ ls -a

来查看该文件，类似.main.c.swp，是个隐藏文件。

如果已经打开了一个文件，并且需要继续写代码而不想关闭，有需要打开另一个文件来编
辑，这时就可以利用Vim的多标签功能了。执行命令: >

    :tabnew login.c

你将会看到在界面最上方出现一个标签页，显示了正在编辑文件的文件名。 这便是Vim的
多标签功能了，一个文件名便是一个标签，代表那个标签下的在编辑文件。这个使用过类
似UtralEdit的读者应该会熟悉。 如果命令后面没有文件名，则会新建一个空标签页，用
于新文件的编辑。

使用标签打开的话，因为是新开文件，只可能会出现发现swp的错误。 但是如果已经打开
了一个文件，而使用标签再次打开该文件时，Vim不会提示错误。 此时便是将同一个文件
在两个标签页中进行编辑，Vim自己会对两个标签页下的内容进行同步，不需要担心。

新开标签页命令执行之后，会自动将当前编辑标签页切换到新开的标签页，如果要回到以
前的标签页进行编辑呢？控制台下鼠标并不能进行标签页的切换。

要在标签页之间切换，首先要回到普通模式下(<esc>即可)。

*ShiftTab*
-----------------------------
gt, gT

gt [go-tab] ，又看到组合快捷键了。 连续键入g和t之后，Vim会切换到当前标签页的右
侧标签页上。值得注意的是，标签页的切换是循环的，也就是说，如果在最右侧的标签页
执行gt，那么会切换到最左侧的那个标签页上。

gT的意思呢，有了上面的经验应该知道了吧，这个和gt的区别就是标签页的切换方向是向
左的，和gt的切换方向相反。

第三种打开文件的方式就比较特别了，我比较喜欢这种方式，那就是分割窗口。这里对窗
口解释一下。Vim中的窗口不是通常意义上图形界面中的窗口，而是Vim的一个编辑区域，
一个编辑区域用于编辑一个文件。如果有多个标签页，则表示有多个窗口，此时，一个标
签页对应一个窗口。 但是Vim提供了一种分割窗口方法，可以在一个标签页中打开多个窗
口，即一个标签页中有多个编辑区域，每个编辑区域用于编辑各自的文件。

这种方式特别好用。 例如，在一个标签页里同时打开两个窗口，一个用于显示c文件，一
个显示该c文件所调用的接口函数的h文件，这样可以方便地直接在该文件中看到接口函数
的声明格式了，而不需要使用gt来切换标签页进行查看。

分割窗口有两种分割方式。第一种命令如下: >

    :sp login.c

sp [split] 命令执行后，会将当前窗口分割成两个， 并且是水平分割，即两个子窗口是
一上一下的，两个窗口的高度默认为原窗口的一半。新窗口位于上方，并打开了login.c
，此时的输入焦点也在新窗口上。窗口之间会有一个水平的状态栏，这是上方窗口的状态
栏，用于显示上方窗口的一些信息，比如文件名、光标位置等。

如果命令后面的文件名为空，则两个窗口显示同一个文件。同步问题如同tabnew中的一样
，也不需要你担心，Vim会帮你搞定的。

另一种方式的命令是: >

    :vs login.c

vs [vertical-split] 与sp相似，只不过是垂直地分割窗口。执行效果就是两个子窗口一
左一右，宽度为原来窗口的一半，中间有一个垂直条进行分割。其他效果和sp一样。

需要注意的是，sp和vs是可以一直使用的。也就是说，你在当前窗口使用了一次sp之后，
如果在一个子窗口中再使用vs，就会在当前标签页下得到三个窗口了，其中一个占总面积
的一半，另外两个窗口各占四分之一。即第二次的vs是把第一次的一个字窗口当作父窗口
来进行分割的。

同样的问题又出现了，如何在窗口之间切换呢？

*ShiftWindow*
-----------------------------
CTRL-w + [h, j, k, l]

组合快捷键越来越复杂了！其实这个也是只需要两次输入的组合快捷键。命令的第一次输
入是CTRL-w [Window] ，即同时按下Ctrl加上w， 在提示区出现"^W"的字串(在Vim中"^"
一般表示Ctrl按键)，表示是要进行窗口操作了，等待第二次输入以完成整个组合键。 第
二次的输入有四个选择，分别为h, j, k, l，四个按键分别代表用于选择的四个方向，分
别是左、下、上、右。输入第二次的输入后，提示区的字样会消失，然后光标会移动你所
选择的那个窗口上。

关于为什么是h, j, k, l表示那四个方向呢？后面会详细介绍。

以上便是Vim中常用的打开文件的方法了。其他的方式，这里就不一一介绍。

*SaveFile*
--------------------------------------------------------------------
在编辑文件之后，需要对文件进行保存。如果是新文件，则需要传递一个文件名；如果是
已有的文件，则直接保存即可，不需要额外的文件名参数，如果传入了文件名参数，则将
当前的内容另存为该文件名指定的文件，同时原文件也完成保存操作，当前的编辑文件仍
然为原文件。

保存的命令为: >

    :w

w [write] 命令就是将修改保存到文件中。实际上是将swp中的内容写到原文件中。 应该
养成良好的习惯，没事就输入一下:w来保存修改，就像使用其他编辑器随手CTRL-s一样。
执行该命令之后，状态栏左侧会给出已保存的信息，包括文件名、文件行数和字符数等。

而对于当前使用多标签页或者多窗口编辑多个文件时，可以使用如下命令: >

    :wa

wa [write-all] 可以一次性将在编辑的所有文件的修改都执行保存操作。

*Quit*
--------------------------------------------------------------------
在所有的编辑工作完成之后，需要退出Vim。如果退出之前对文件做了修改且没有保存(上
方文件名前会有个+号)，执行退出时会提出警告，要求进行保存后再退出。如果想要放弃
修改直接退出，则是在退出命令之后添加!以强制执行退出命令。!在前面打开文件中也有
所提及，可见命令后面增加!表示强制执行该命令。

退出的命令为: >

    :q

q [quit]执行之后，会关闭当前窗口或当前标签页(如果标签页内只有一个窗口的话)。另
外一个组合命令: >

    :wq

表示先保存然后退出，这样使用者就不需要执行两次命令输入了。而命令: >

    :qa

则和wa命令一样，可以一次性将所有在编辑的文件全部关闭然后退出程序。

自此，Vim中常用的文件操作已经介绍完了。 可以看出，对文件的操作大部分是命令，而
切换标签页和窗口操作则是普通模式下使用快捷键完成的。


*NavigationJump*
==============================================================================
在了解了如何打开和保存需要编辑的文本之后，接下来就来看看如何在文本中进行移动。
这里说得专业点，叫做“导航(navigate)和跳转(jump)”。 Vim帮助文档里面将这类操作叫
做motion操作，在文档后面的行文中统一将这些移动的操作叫做motion。

查看motion的帮助可以了解更多: >

    :help motion

移动，也就是将输入点，这里是光标，进行移动，然后在光标处输入文字了。以上可能是
大部分其他编辑器使用者的想法，因为对于他们来说，移动并不是很复杂的问题，只要使
用鼠标，指哪打哪；或者使用方向键进行短距离的移动。

然而在Vim中，移动，即导航和跳转，却是比较庞大和复杂的点， 需要初学者花时间好好
学习和适应，这也是陡峭学习曲线中的一部分。 当然，如同模式一样，Vim的难度在另一
个层面上造成了它的强大。

Vim中的移动发生在普通模式下，通过各种快捷键来进行。Vim中编辑操作的一般过程是：
使用motion操作将光标移动到预期的位置之后，执行NI操作切换为插入模式进行文本输入
，之后又退回到普通模式，再进行下一次的移动。

Vim中的移动可以分为两类：导航以及跳转。 两者的区别其实没有那么大，读者可以认为
是我自己强制的一种分类吧：导航是小范围的移动；而跳转是大范围且并不确定执行后
光标位置的移动。

*Navigation*
-----------------------------
h, j, k, l, w, e, b, f, F, t, ,, ;

其中h, j, k, l四个键在上面的窗口切换中已经出现过了，用于表示四个方向。在普通模
式下面，这四个键用来将光标向四个方向进行移动。h为向左移动一个字符，l向右移动一
个字符，j向下移动一行，k向上移动一行。其中h, l的移动范围仅为光标所在行。例如，
一直键入l，如果到达了行尾，光标并不会从下一行的行头继续向右移动， 且终端会发出
警告声(大部分情况下是响铃)。

在本文档的后面，统一将向右移动和向下移动称为正向移动，将向左移动和向上移动称为
反向移动，以方便表述。

至于为什么是这四个键来做四个方向的移动快捷键呢？这四个字母又是什么的缩写呢？其
实没那多讲究了，只是因为这四个键是手在键盘上最容易接触到的、键程最短的四个键而
已，而基本移动是最为最频繁的移动动作，当然就选最容易按下的这四个键来触发了，就
这么简单。

但是初学者就会问了：我一点都不习惯，一点都不觉得方便啊，还不如用方向键来得快！
但是如果适用方向键的话，右手就需要离开主键盘区了，会影响效率。而且只要你花一点
时间熟悉这四个移动指令之后，以后就能不经过思考条件放射地按下相应的键来执行想要
的移动了。这时你就会发现这四个键真的非常方便呢。

按理说，有这四个键就已经可以将光标移动到任何位置了，但是这样就和普通的编辑器没
有区别了，Vim当然有更强大的移动指令。

对于编辑文本来说，单个字符或者汉字当然是最小的处理单位，再高一级的处理单位就是
单词了。如果能够以单词为单位进行移动，肯定会比一直按着h、l键效率更高，尤其是对
于编写代码来说。

w [word], e [end], b [back]三个键就提供了以单词为单位移动功能。w以单词作为基本
单位正向移动光标，光标每次停留在单词的第一个字母上；e和w一样，只不过每次停留在
单词的最后一个字母上；b则是向左移动光标，光标停留在第一个字母上。

这三个键虽然和h, l一样，都是将光标左右移动，不过不同的是，它们的移动范围并不局
限在光标所在行，而是窗口的所有文本。 例如，一直使用w，光标会以单词为单位一直正
向移动，当碰到行尾时，光标会移动到下一行的第一个单词的首字母上。其他二个也是如
此。

你试下这三个键，是不是发现移动速度快了很多呢？但是这样就满足了吗？试想这样一个
场景，光标位于行头，而这行中间有个单词configure打错了，写成了confagure，你需要
将写错的a改成i，你会怎么做呢？

如果一直用l移动到a上，然后键入ri当然是可以的，不过移动略显得慢了点。那么使用w
呢，一直用w移动到confagure的首字母上，然后使用l移动到a上进行修改。这样速度也提
升了不少。不过还有第三种更快的方法，那就是使用f。

f [forward] 的移动单位是字符，只不过是在同一行中的相同字符之间移动。具体使用方
法是：首先按下f，表示将要正向移动，此时在右下方会出现"f"字样，表示你已经键入了
f，并等待下一个输入。这是一个组合键。 第二个输入就是你想要移动到的那个字符，例
如上面的例子中，想要移动到a上，则第二个输入就为a。此时提示区的提示消失，表示输
入完成。 此时光标便会从当前位置移动到正向的第一个a上。这样便可以很快地将光标移
动到你想要的地方了，精确制导！

如果在confagure之前还有单词and，那么以上的操作执行之后，光标将停在and里的a上。
此时继续键入fa，然后光标会继续移动到正向的第一个a上的。 不过这样似乎比较麻烦，
已经输入指令了，为什么要又输入一遍呢。这时便要使用到是";"和","了。

在你第一次输入了fa之后，表示要在同一行的a之间移动。如果按下;，则会直接正向移动
到下一个a处；按下,，则会反向移动到上一个a处。

和l, h一样，f, ;和,的移动范围也只是光标所在行而已。 移动到该行最后一个目标字母
之后，并不会移动到下一行的第一个目标字母处。

至于F，根据已经看过的大小写的按键的规律， 它是反向移动到目标字母。同样可以配合
";"和","使用，只不过此时";"和","的方向相反了哦。

t [till] 效果和f类似，只不过f会将光标放置在目标字符上，而t则是将光标放置在目标
字符的前一个字符上，和till的意思一致。另外，t操作并不能和;以及,配合使用。

*Jump*
-----------------------------
^, 0, $, %, [[, ]], gg, G, L, H, M, m, ', :[number]

接下来介绍跳转操作。

首先是^和0。^(也就是shift+6)字符输入后，光标会移动到本行的第一个非空白字符处；
而0则是移动到该行的行头，而不管是不是空白字符。 这点区别在编程中尤其明显，因为
代码一般都会有缩进，而不管是tab缩进还是空格缩进，都属于是空白字符， 所以一般编
写代码时^使用得较多。

不过看到“第一个非空白字符”是不是感觉有点熟悉呢？在前面介绍模式切换的NI操作里有
一个I快捷键，作用是在当前行的第一个非空白字符之前插入文本。这就好比是按下^之后
再按下i。I在使用行注释(即"//")的时候还是非常方便的哦。

$则是移动光标到行尾。它和A的关系，就如同^和I的关系一样：A = $ + a。A在添加行尾
注释的时候十分方便。

根据我的经验，在写代码的过程中，大部分需要考虑行头和行尾的情况，要么是在行头插
入"//"注释本行代码，要么就是在行尾插入"//"写注释。因此，使用I和A会较多，而使用
^和$则相对不会很多，几乎不怎么用。就算不是和注释有关，而仅仅只是想要移动到行头
或行尾，我也会使用I和A，然后<esc>，而不直接使用^和$， 因为后两个键程有点远，不
想按。

%是一个很强大的跳转指令。在介绍%之前，先插播一个配对的概念：

在文本编辑时，我们一般会使用([{}])这类的字符，来括起一些内容。那么(和)、[和]、
(和)便是配对的关系，姑且将这六个字符就叫做配对字符。

%有两个作用。 第一个作用是查找配对字符，就是找到本行光标正向的第一个配对字符。
查找会碰到两种情况。第一，如果光标所在的字符不是配对字符，那么光标会正向跳转到
下一个配对字符；如果该行没有配对字符，那么终端会给出警告声，并且光标不移动。第
二，如果光标所在的字符就是配对字符，那么光标将会跳转到和该字符所配对的那个字符
上，这便是%的第二个作用：配对跳转。 因此，如果移动到了行中的配对字符，那么一直
执行%的结果就是光标在那两个配对字符之间跳来跳去、跳来跳去...

说过%很强大，因此还没完呢。在C语言里，(、)用来括起函数参数的，[、]用来定义数组
的，{、}则用来定义代码块的。因此在C代码编写时，%的跳转功能就十分有用。特别是对
{}的跳转，可以在函数定义开头跳到该函数结尾处， 可以在if-else语句中找到条件判断
的匹配。

Vim对这些配对字符的另一个关照之处是： 如果开启了语法高亮(下面会介绍)，当光标位
于一个配对字符上时，光标会改变颜色(具体什么颜色和配色方案有关，下面会介绍)，并
且和该字符配对的另一个字符的颜色也会改变，和光标处的一致。这样可以很显眼地发现
该类字符的匹配，对编写代码来说，十分便利。

对%的介绍还没完呢。在C代码编写中，除了上面提到的配对字符之外，还存在着另外一些
的“配对”的事物，有：/*和*/以及#if、#ifdef、#else、#elif、#endif。%的配对跳转同
样适用于这些“配对”的事物，只不过配对字符查找的作用就不适用了。对于条件宏十分有
用，可以很方便地查看该条件宏作用范围多大。

]]为组合键，输入后会在文本中查找下一个位于行首(或者叫做第一列)的"{"字符， 并跳
转到该字符上。而[[相反，是跳转到上一个该字符上。

该功能目前最大的功用是在C代码中在函数定义之间跳转。 因为每个函数的定义的开头都
是独占一行的"{"，因此这个跳转指令很方便。 不过对于不采用这种代码风格的代码该跳
转指令就不适用了。

gg的跳转就没有上面介绍的跳转指令那么复杂了，就是简单地跳转到整个文本的第一行。
而G也简单，和gg相反，直接跳转到整个文本的最后一行。

L和H呢，如果按照前面的“大写规律”来判断的话，l是向右移动一个字符，那么L应该就是
向左移动了；h是向左移动一个字符，那么H就是向右移动咯。呃，好像有点不对...

事实上，L是将光标移动到最后一行，H是将光标移动到第一行。但是和gg和G不同到是，
gg和G的跳转范围是整个文本，而L和H的跳转范围则是当前屏幕显示的范围。

M和L、H是一个系列的，将光标移动到窗口的中间。可以这样记忆：L [low]，H [high]，
M [middle]。

m和'是配合使用的跳转指令，稍微复杂一点。 这和Vim中的寄存器机制有关系，不过比较
复杂，这里不展开说明了。 简而言之，就是Vim运行后维护一套寄存器，用来暂时存放一
些设置或标记等信息。 一般用字母或数字作为名字，即a-z、A-Z和0-9，以便外部访问和
引用。 而m和'的使用就和寄存器有关。

关于寄存器权威和详细的说明，请查看Vim的帮助文档: >

    :help registers

在键入m之后，在提示区会出现"m"字样， 表明m是组合键的第一次输入，后面应该要继续
输入，以便完成该组合键。这里应该输入寄存器名称，也就是输入a-z或A-Z中的任一字母
(该命令不使用数字名称寄存器)。假设输入了a，那么"m"字样就会消失，表示完成了输入
并随后执行命令。

命令执行之后，表面上没有什么变化，实际上， Vim已经将当前光标所在的位置信息放在
名称为a的寄存器中了，这相当于做了一个书签。m可以理解为 [mark]。

执行ma，添加了该书签之后，你可以继续编辑文本，继续移动光标。而当你想要回到刚才
那个位置来查看或修改时，因为在该位置已经使用过ma，做了书签标记，此时，你只需要
键入'。这同样也是一个组合键，会在提示区出现"'"字样，随后键入存放该位置信息的寄
存器，即a，此时光标便会立即跳转到所做标记的位置了。'是跳转命令。

如果在修改了ma处的文字后，想要回到跳转前的地方继续编辑怎么办呢？聪明的读者可能
会想到在执行'a之前先执行mb，以保存一下“返回地址”， 完成a处的修改后再执行'b就可
以回到原来的地方继续工作了。这不失为一个方法，但是Vim提供了一个更优雅的方法。

在编辑时，发现要跳到以前ma的地方进行修改，这时你直接执行'a即可。再完成修改之后
只需执行''，即两次输入'，就可以返回到原来的地方，继续工作了。操作中的第二个'可
以看成是一个临时寄存器，自动保存每一次跳转前的位置。

需要注意的是，这个书签适用的范围是该文件。例如，你在main.c执行了ma，那么在该文
件中执行'a会跳转到a处，而在login.c中执行'a则会没有反应。 如果login.c中也执行了
ma的话，'a的结果也是跳转到login.c中的a处，和main.c是没有关系的。即，每个所打开
的文件有自己的一套的书签标记寄存器。

另外，即使所做书签的行的行号发生了变化，使用'仍然能够准确地跳到该行上去。 这说
明该机制不是简单地使用行号来记录位置信息的。

m和'在代码编写中十分有用。例如，你可以在源文件的宏定义处执行ma。在接下来的代码
编写过程中，如果需要查看某个宏的具体名字或具体值，执行'a即可跳转到宏定义处查看
，之后执行''即可回到原来的位置继续编写。

而:[number]则是命令模式的一种用法。 例如在编译程序时，编译器报错，并给出出错信
息为某个源文件的120行有个错误，那么可以在该文件窗口中直接输入: >

    :120

便会直接跳转到文本的第120行。关于Vim和编译器的配合使用，后面会有更详细的介绍。

自此，常见的跳转指令介绍完了。这里主要介绍的是一般文字编辑工作也能够常用的到指
令，还有一些和代码结合性较强的跳转指令会继续在后面会详细介绍。

*ShiftPage*
-----------------------------
CTRL-f, CTRL-b, CTRL-d, CTRL-u, zz

这里将翻页操作和motion操作分开了，因为翻页动作和移动光标还是有区别的：翻页是用
于大范围的移动文本，而不是为了准确地将光标移动到某个位置。

一般编辑器中的翻页，特别是大段大段的翻页，要么是手指抽风似地狂用鼠标中键，要么
是使用PageUp或PageDown键。 而对于Vim来说，这些都会让双手离开主键盘区，从而影响
效率，因此提供了以上的翻页快捷键。

CTRL-f [forward]用于整屏正向翻页，作用和PageDown一样； CTRL-b [back]用于整页反
向翻页，作用和PageUp一样。

CTRL-d [down]用于半屏正向翻页，CTRL-u [up]用于半屏反向翻页。是比较特别的翻页模
式，但是很实用。

zz可以将光标所在行居中，也就是说vim会自动翻动屏幕， 将光标所在的那行移动到屏幕
的中间。这个十分实用，特别是配合一些导航功能使用。

自此，相信读者应该已经能够自如地操纵Vim来移动光标到自己想去的地方了吧。 那么准
备工作就到此齐全了，下面开始正题，进入实质的编辑操作。


*BasicEdit*
==============================================================================
基本的编辑操作一般包括输入文本、删除文本、移动文本、撤销重做。

在进行输入之前，需要先切换到插入模式。在前面的模式切换中所介绍的各种NI操作已经
能够满足各种需求了。当然NI操作不仅仅只有那些了，还有很多，只是不常用而已。

*DeleteText*
-----------------------------
x, d, dw, d$, dd

x用于删除当前光标下的字符。虽然看起来像是删除，但x实际上是进行了剪切，并将剪切
掉的内容放到寄存器中，x的样子像个剪刀吧。 寄存器又出现了！只不过这里的寄存器和
前面介绍的位置信息寄存器是不同类型的。Vim提供一个寄存器(帮助中说是寄存器x)，自
动记录每次被删除的文本，该寄存器在每次的删除操作之后会自动更新。

x用于删除单个字符很好用。 这样就不需要先进入插入模式，然后使用后退键来删除字符
了。不过x作为剪切，具有更强大的用法，在后面的组合操作中会详细介绍。

d [delete] 操作，这个才是正宗的删除操作(看名字就知道)。当键入d之后，在提示区会
出现"d"字样，需要下一个输入。 而该次的不同输入造成了不同的执行效果，读者可以把
这些看做不同的删除指令。

dw [delete-word] 的删除单位是单词， 会正向删除从光标开始算起的一个单词，包括光
标下的字符。如果你要删除一个单词，首先将光标移动到该单词首字母上，键入dw即可。

d$是从当前光标(包括光标下的字符)正向删除到行尾。

dd则是删除掉光标所在的一整行。

和x操作一样，d操作之后，所删除的内容会存放到寄存器x中。 在后面的编辑中可以取出
来使用，后面马上会介绍。

dw和d$的第二个输入(w和$)是前面所介绍过的motion操作。而dw和d$所删除的文本范围也
正好分别是w和$的移动范围。读者可以尝试一下dl、d^、d0等操作。 这是Vim所提供的一
种机制，在后面|CombineOperation|中会详细介绍。

前面在介绍NI操作时，里面的s和cw也实现了删除效果， 只不过删除之后立即就进入了插
入模式。因此，s = x + i, cw = dw + i，如何选择使用，看读者自己的习惯。

*MoveText*
-----------------------------
x, y, Y, p, P, "+y, "+p

这里的移动文本其实是一个组合的操作：首先选择要移动的文本；然后剪切或者复制该文
本；最后粘帖该文本。这样便完成了文本的移动了。这里分别给出剪切、复制和粘帖的操
作。

剪切操作x在上面已经介绍过了，放在之前介绍是因为它用来删除单个字符非常好用。 其
实它的本职工作是剪切。

y [yank] 用于复制，和x一样，执行结果后的文本会存放到寄存器x中， 以便粘帖操作命
令使用。

在键入y之后，提示区会出现"y"的字样，随后的输入是motion指令，表示要复制的范围。
这和删除指令d一样的，可以参考d的介绍。比较常用的是yy指令，复制光标所在行。

Y同样也是复制命令，效果和yy一样，不过我一般比较喜欢yy(大误)，因为输入快点。

p [paste] 则是将寄存器x中保存的文本取出， 然后将其粘帖到光标所在位置的后面。而
P则相反，将文本粘帖到光标所在位置的前面。

前面也提到过，删除文本的指令也会将所删除到的文本存放到寄存器x中， 因此随后执行
p也能够粘帖将被删除的文本。从这方面看来，剪切指令和删除指令是一个效果的。

例如，你想要移动一行代码：光标移动到该行代码后，执行dd删除掉该行代码，然后移动
光标到目标位置，执行p即可。p操作会将该行代码复制到光标所在行的下方。

如果只是在Vim中的文件之间进行复制粘帖，这三个命令是能够胜任的。 但是当要和其他
应用程序复制粘帖时，你会发现y, p没有效果，复制粘帖的都只是Vim中的文本。 这是因
为x, y, p操作的文本都是存放在寄存器x中的， 而该寄存器在当前Vim程序中是全局唯一
的，因此各个标签页或窗口之间是可以共享该寄存器中的内容的；但是系统中的其他程序
却不能够访问到该寄存器，系统中的复制粘帖操作的是系统提供的复制粘帖板，因此使用
这三个命令是不能与外部程序进行复制粘帖的。

这种情况下，就需要下面两个命令来和系统的复制粘帖板打交道了。

"+y，该命令用于执行复制操作，复制文本到系统复制粘帖板；"+p则是从系统复制粘帖板
取出文本进行粘帖操作。

这里首先出现了需要三次输入的组合键，读者应该都会嫌这种不太快捷的快捷键吧。不用
烦，强大的Vim当然会提供强大的功能来弥补的，这就是map键映射功能，简单来说就是将
一串操作序列映射为一个按键。比如我就将"+y映射为<F2>，将"+p映射为<F3>，这样每
次执行系统的复制粘帖就只需要按<F2>、<F3>即可了。关于映射功能下面会介绍。

在知道x、y、p的作用之后，如何使用呢？这里就涉及到文本的选择操作了。 插播一下对
可视模式的介绍。

*VisualMode*
--------------------------------------------------------------------
前面提到过，可视模式是用于对文本进行选择的。

这体现了Vim的设计理念，同样也是Unix的哲学，即将工具组合起来使用。Vim中每个指令
能够高效地完成一个简单任务，而将各种指令组合在一起，就可以完成非常复杂的工作了
。并且通过灵活的组合，可以应对各种各样的需求，d + <motion>便是一个例子。这里要
介绍的可视模式也是一例。

可视模式提供强大的选择文本的操作，并只是用于选择文本，至于选择之后如何操作这些
文本，则取决于使用者后续输入的操作命令。

可视模式分为三种：普通可视模式、可视行模式以及可视块模式。如何进入在NV操作中已
经介绍过了，分别是v、V和CTRL-v。

进入到可视模式之后，都可以通过motion操作移动光标来选择你要选择的文本区域，已选
中的文本区域会被高亮显示。其中普通可视模式是以字符为单位选择；可视行模式以行为
单位选择；可视块模式则是进行列块选择，即选择区域为矩形。

假设要选择一个单词， 可以在该单词首字母上进入普通可视模式，然后键入e，光标会移
动到该单词末尾，此时整个单词被高亮显示，也就选择了整个单词。随后便继续可以键入
要对该单词执行的操作，键入x，便剪切掉该单词，y便复制该单词。

再如，要将10行代码复制到另一个文件中去，首先进入可视行模式，然后移动光标选择这
10行代码，随后键入y完成复制。切换到需要粘帖的文件后，键入p，即可将这10行代码粘
帖到该位置上了。

再如，要删除掉一个函数的函数体，当然你可以使用可视行来选择。但是如果函数体很多
行呢，岂不是要键入j很多次？ 这时应该使用其他更好的motion指令：先将光标移动到函
数体定义的{处，然后进入可视行， 之后键入%以跳转到和函数定义开头所匹配的}处，这
样便选中了整个函数体。最后键入d完成删除。

从上面的例子中可以再次看到，Vim中各种快捷键的组合操作的灵活性。

这里特别介绍一个可视块模式的用法。在编写代码过程中常常需要将一个多行的代码块注
释掉。 在C里常用的做法是使用"/*"和"*/"将该代码块括住即可；也可以在代码块的每行
代码前添加"//"进行注释。当然是前者较为方便；甚至可以使用#if 0和#endif来注释。
不过在某些对代码风格要求严格的项目中或者一些脚本语言例如python中，必须要使用行
注释而不能用块注释时。这时就可以使用可视块模式来完成了。

首先将光标移动到要该代码块第一行的行首字母上，进入可视块模式，然后移动光标到该
代码块的最后一行的行首字母上，这时会高亮显示一列。之后键入I，注意不是i，此时信
息区显示的是插入模式了，然后键入注释符"//"，将第一行注释掉，而其他行没有变化。
不用着急，最后键入<esc>退回到普通模式。 此时其他被选中的行的前面都添加了注释符
被注释掉了。
-------------------------------------------------

好了，插播结束，配合着可视模式的选择功能，就可以灵活地使用移动文本的操作了。下
面介绍编辑过程中另一对常用的操作：撤销和重做。

*UndoRedo*
-----------------------------
u, CTRL-r

撤销和重做是编辑器不可缺少的功能，是使用者的后悔药，一般现代编辑器都会提供这样
的功能。

在Vim中使用撤销很简单，键入u [undo]即可；使用重做也很简单，使用CTRL-r [redo]即
可了。并且每次执行撤销或重做时，状态栏都会给出相应的动作信息，比如发生什么啊，
什么时候发生的啊。

自此，在本节基本的编辑操作介绍之后，读者应该能够使用Vim完成各种编辑任务了。 后
面开始介绍一些稍微高阶一些的操作。


*CombineOperation*
==============================================================================
这里不得不再提到Unix哲学之一：每个程序只做一件事，并且做好；不同的程序配合使用
完成复杂的任务。该思想不仅在程序设计中、在Unix各种工具的使用中体现了， 在Vim中
同样体现的淋漓尽致。

通过前面的介绍， 读者应该对于在Vim中，各种指令之间如何配合使用有了一个感性的认
识。下面就按照分类，系统地介绍一下Vim中的组合操作。

需要说明的是，该分类也是我自己整理出来的，至少在目前来说是适用及合理的。更权威
的分类和说明，请读者查看Vim的帮助文档。

*CountCmd*
--------------------------------------------------------------------
第一个组合方式用Vim帮助中的形式可以表示成：count+cmd。首先输入数字，然后输入指
令。这里的数字表示你想要将随后输入的命令执行多少次。而后面的指令可以是简单的一
次性快捷键输入，也可以是复杂的组合输入。

你在Vim中通过操作序列来完成的工作， 都可以通过事先输入数字来重复做多次这样的工
作。可能这样说还是有点抽象，下面给出几个例子来说明。

首先来个简单的，在普通模式下键入10j。 在输入数字10之后，提示区会出现"10"字样，
表示在等待继续的输入已完成该次组合操作。随后输入j，j的执行结果是将光标向下移动
一行。这个组合操作的结果就是执行了jx10，即执行了10次光标下移一行，即光标下移了
10行。

这个例子也可以搭配可视模式使用。例如需要选择10行，则可以先进入可视行模式，然后
键入10j，便会高亮选中下面的10行了。

除了motion操作之外，前面提到的dw、dd、gt等组合操作都可以作为指令配合数字使用。

再举一个例子。在一个空行下键入78i=<esc>。 出现的东西是不是很熟悉呢，就是我在文
中每个章节下使用的分割线。

那么如果对于使用=作为分割线不太满意，想要改成-，怎么做呢？ 键入0回到行首，然后
键入78r-，即执行78次替换，便可以将改行所有字符替换成-字符了。(或者使用可视行模
式)。

*CmdMotion*
--------------------------------------------------------------------
第二种组合方式可以叫：做带移动的组合命令，效果就是将操作应用到所移动的范围上。

其实前面已经有了很多该方式的命令，例如cw、dw、de、d$、yw、yy等等；还有比较复杂
的：比如dfa，则是表示从光标处删除到正向第一个a字符处。

而motion指令配合可视模式的使用方法也在|BasicEdit|中进行了介绍。

*RangeCmd*
--------------------------------------------------------------------
第三种组合方式用Vim帮助文档中的形式可以表示成：range + cmd。 其中表示range有两
种方式。

第一种是使用可视模式来进行选择文本，高亮区域即为range。 首先选中需要进行操作的
文本，然后输入操作命令。这种组合命令在|Basic-Edit|中插播可视模式时已经进行了介
绍，这里就不赘述了。

第二种则是键入表示范围的符号，之后接着输入操作命令，即可将该命令应用到所表示的
范围上。例如键入: >

    :%d

就是删除整个文本了，%表示的范围是整个文本。而输入: >

    :60,70d

指定的范围就是从60行到70行，然后删除60行到70行之间的内容。

*Record*
--------------------------------------------------------------------
第四种组合方式是宏。只不过宏这个名字是坊间流传的， 可能和Office里面VBA中的宏录
制相似吧。而在Vim帮助文档中，它的官方叫法是记录 [recording]，执行命令: >

    :help recording

来查看详细的说明。

*record*
-----------------------------
q, @

q(和命令模式中使用的退出命令有区别)在记录过程中需要使用两次： 第一次表示记录的
开始，第二次表示记录的结束。第一次键入q之后，提示区出现"q"字样，此时的输入应该
为小写或大写字母或数字，用以表示使用哪个宏寄存器来存放这次的记录信息。这里又出
现寄存器了哦，和m操作一样，输入的字符用以表示寄存器。

在第二次输入之后，提示区的"q"字样消失，在信息区出现如下字样: >

   recording 

这表示开始记录了。你可以把这个看作一种特殊的模式：记录模式。由此时开始，你所做
的所有的按键操作都会被记录下来。 直到你再次键入q，表示该次的记录结束了，所做的
记录信息存放在开始时指定的寄存器中。

m和'搭配使用，q也有@来配合。 @表示读取指定寄存器中的操作记录，并将这些操作顺序
地重新执行一遍。

例如，键入qa之后，指定寄存器为a，然后开始记录。键入的操作序列为"jI//<esc>"。输
入完这些指令之后，再键入q，表示结束记录。 该操作序列执行的动作是：将光标移动到
下一行，然后在该行行首输入注释符"//"，然后键入<esc>回到普通模式下。 该操作的功
能就是将光标的下一行行注释掉。

记录完该宏之后，如果键入@a，则会执行寄存器a中的操作序列，将下一行行注释掉。 这
样就不用你再次从头输入一遍该操作序列，在进行长且重复操作时尤其方便。

另外，将宏和数字结合使用可以使得操作序列多次执行。例如在上例中，如果需要将连续
的20行代码进行注释，那么在记录该宏之后键入19@a，便可以通过一条指令将剩下的19行
代码注释掉了。

自此，对于组合操作，或者说是我所了解的组合操作，便介绍完了。读者可以在实际的使
用中灵活的运用各种指令搭配使用，来完成复杂且重复的操作。


*SearchSubstitute*
==============================================================================
搜索和替换在编辑过程中使用的非常多，特别是搜索，特别是在代码编写时搜索，特别是
对所写代码老记不住的程序员的搜索。

*Search*
--------------------------------------------------------------------
这里首先介绍搜索功能，然后介绍替换功能。

*search*
-----------------------------
/, ?, *, #, n, N, gd, gD

/用于正向搜索符合要求的字符串，而?用于反向搜索符合要求的字符串。 这里以/为例进
行介绍。

前面在|Mode|中的|NC|操作中提过，在键入/之后会进入到搜索的命令模式， 在信息区出
现"/"字样，并等待输入要进行搜索的字符串。

/后所输入的字符串在Vim中被称为模式 [pattern]，其实质是正则表达式。但是和正则表
达式又有些许区别，加入了一些Vim自己定义的元素。详细的可以输入: >

    :help pattern

来查看Vim中对pattern的定义。这里只介绍一些简单的搜索应用，更复杂的应用可以在学
习正则表达式以及Vim对其的扩展之后来进行。

例如你要搜索变量"Status"，以便查看代码在哪里对它进行了访问。 键入/Status，然后
回车，便会自动跳转到下一个Status所在的位置。如果设置了搜索高亮显示，则文本中所
有匹配的字符串会被高亮显示出来。要设置搜索高亮可以执行命令: >

    :set hls

其中hls是highlight search的缩写。后面会详细介绍如何对Vim进行设置。

如果在搜索中需要不区别大小写，则可以输入命令: >

    :set ic

ic是ignore case的缩写。

下面给出几个和正则表示式应用相关的例子。例如你要搜索"."字符，可能会直接输入: >

    /.

是不是文字都被认为匹配！ 其实"."字符是正则表达式中具有特殊意义的字符，表示匹配
任意一个字符。那/.不就是表示搜索任意字符了吗，所以所有的文本都被高亮了。

如果要搜索一些特殊字符的话，需要使用转义符。 转义的概念和c语言里printf()中使用
的一样。要搜索"."字符的话，需要键入: >

    /\.

\表示对后面的字符转义了，这样搜索的结果就如预期一样了。

如果想要一次同时搜索多个模式的话呢，可以键入: >

    /status\|bar\|my

该命令会同时搜索字符串"status"、"bar"以及"my"。 \|表示"|"字符，进行了转义。|表
示或的意思，即同时对个模式搜索。

在执行搜索之后，如果有多个搜索结果，那么当然想每个结果都查看一下。对于习惯其他
编辑器的人来说，这时会下意识的使用<F3>吧，呵呵。不过Vim中有另外的快捷键。 

n [next]用来在搜索结果之间进行跳转，为正向跳转。并且在跳到文本中的最后一个结果
时，如果继续执行n，会自动跳到文本中的第一个结果处，同时会在信息区给出提示， 表
示已经结束了对整个文本的搜索跳转了，很贴心哦。

命令N，大家应该已经猜到了吧，没错，是反向跳转到上一个结果处。

有时会有这么一个需求，你当下的语句中调用了变量Status，然后想搜索一下该变量，以
便查看这个变量的调用情况。当然可以键入/Status来进行搜索。 但是利用光标正位于这
个单词上，这时你不需要键入要搜索的变量名了，直接键入*即可。

执行*，效果就等同于/，只不过变量自动取自光标下的单词，不需要再输入了。是不是很
方便？

*和/另外一个区别就是： 如果文本中有字符串是包含了要搜索的模式时，/的搜索结果包
含该字符串的，而*不会，即非完全匹配搜索和完全匹配搜索的区别。例如键入/Status后
，如果文本中有变量名为BarStatus的话，那么这个变量名也会被跳转到；而*只会搜索到
单词Status。

不过该区别可以使用正则表达式来解决。 输入/\<Status\>，表示只搜索匹配的单词，而
过滤掉包含该模式的字符串。效果和*是一样的。

#则和*效果类似，不过是反向进行搜索的。

gd [goto-declaration] 跳转至光标下变量的局部声明处。当光标下是一个局部变量时，
此命令会跳转到该变量被声明的地方。执行的步骤是：首先，Vim 会找到当前函数的定义
起始处，然后从这里开始正向查找光标下的模式，就像使用了*一样。 但是gd不会去搜索
注释里的字符串，很智能。

gD [goto-Declaration] 则是跳转至全局声明。当光标下是一个全局变量时，此命令会跳
转到该变量被声明的地方。和gd一样，不过查找总是从整个文件的第一行开始。

gd和gD在代码编写中十分有用处，可以很方便的跳转到变量定义或者结构体声明或者函数
声明的地方，用以查看变量类型或结构体成员或函数的定义。 同时也完成了*所做的搜索
动作，可以使用n和N来在本文件中该变量被调用的地方进行跳转。

不过gd和gD还是有局限性的：它们的搜索范围只是本文件内部，而不能跨文件。举个例子
，在main.c中调用了login.c中定义的接口函数login()。当在main.c中编写代码时，想要
查看一下login()的具体实现，使用gD是无用的，只能看到login()被调用，而不能跳转到
login()的定义处，因为login()是在login.c中定义的。

可能读者使用过Source Insight或者Visual Studio，它们能够完成跨文件跳转，那Vim就
不能吗？其实是可以的，不过需要插件支持。关于如何跨文件跳转以及插件，在后面会详
细介绍。

*Substitute*
--------------------------------------------------------------------
下面介绍替换。首先给出Vim帮助中替换的完整模式的命令: >

    :[range]s[ubstitute]/{pattern}/{string}/[flags] [count]

帮助中的说明也一并给出：

"""
对 [range] 指定的行把 {pattern} 的匹配替代成{string}。{string} 可以是按字面意
义的，也可以包含特殊字符。如果不指定 [range] 和 [count]，仅在当前行进行替代。
如果指定 [count]，在 [range] 最后一行开始的 [count] 行进行替代。如果不指定 
[range] ，则从当前行开始。
"""

帮助中的说明还是很严谨、全面和权威的，不过就是稍显抽象了一点。下面给出几个常用
的例子来说明替换的用法。

首先是使用的最频繁的一种替换，输入命令如下: >

    :%s/zhs/ZHS/gc

其中%表示整个文本范围，即帮助中的range。 可见替换也是前面所介绍过的范围+操作命
令的组合操作：指定range之后的操作命令s [substitute]。

第一个/后给出的zhs就是pattern，表示要被替换的字符串。 这个与搜索中的一样，也是
应用正则表达式的。替换不就是先搜索然后把搜索结果进行替换嘛。

第二个/后给出的ZHS就是string，表示替换成的字符串。值得注意的是，如果里面有特殊
字符的话，也需要想搜索模式中一样使用转义符，即\。

第三个/后给出的gc就是flags，表示提供给替换的选项。gc表示提供了两个选项参数，一
个是g [global] ，如果没有该选项， Vim默认每行只替换第一个匹配的字符串的(因为正
则表达式是以行为单位的)， 即是说，如果一行中有两个zhs，没有指定g选项的话，该替
换命令只会替换该行的第一个zhs为ZHS，而第二个则直接忽略； c表示确认，即每次要进
行替换前，Vim都会给出多个选项询问使用者是否对该匹配结果进行替换。

Vim提供的替换选项十分繁多，读者可以键入: >

    :help s_flags

来查看所有的替换选项。

下面给出一个特别的用法: >

    :20,100s/bc/a&d/g

该替换命令的作用范围是从20行到100行，替换掉"bc"，然后替换成"a&d"，并且是全局替
换。哈哈，有个错误。string中的&是一个特殊字符，表示被替换内容，即pattern。结果
就是bc被替换成了abcd。如果要替换成"a&d"的话，需要用\&将&转义。

下面再给个复杂的例子：

将“(1), ...., (2), ....,(100)”替换成“(2), ...., (3), ...., (101)”。 即括号里的
序号数字都加一。如果要在文本中一处处找到并修改是很累的，有100个呢。在Vim下一条
命令就可以搞定: >

    :%s/(\(\d+\))/\="(".(submatch(1)+1).")"/g

解释如下：
  %       全文（“%”是“1，$”范围的缩写）
  s       替换
  /       搜索字符串开始
  (       左括号
  \(      开始记录匹配
  \d+     一个或多个数字
  \)      结束记录匹配
  )       右括号
  /       搜索字符串结束
  \=      把后面的表达式计算出来作为替换字符串
  "("     左括号
  .       字符串连接运算符
  (submatch(1)+1)       把第一个匹配的结果加一作为一个整体返回
  .")"    添上右括号
  /g      替换字符串结束，g表示替换每一行的所有匹配结果。

很复杂吧，反正我自己是写不出这么复杂的命令的，哈哈，这个例子是摘自网上的。不
过这个强大倒不是Vim的强大，而是正则表达式的强大。

自此，关于Vim中的搜索和替换介绍完了。


*AboutProgramming*
==============================================================================
该小节主要会介绍上面所没有涉及到的主题，包括常用命令、配置以及插件。如果没有这
些功能的话， Vim也只不过比其他的编辑器强大一点点而已，而不会成为神器级别的编辑
器。

不过这三个点都是大部头， 每个都可以单独写一个文档了，不信可以看看Vim的帮助有多
少。因此这里着重将三部分中和C语言代码编写相关的内容提取出来介绍。 如果没有这些
功能，使用Vim编写代码可以用喝白开水来形容，平淡无奇，Vim也不会被称为是为程序员
打造的编辑器。这样既可以介绍这三部分功能，让读者熟悉，又可以很好的和应用结合起
来，立即投入实践。下面就先用Vim打开一个C文件，一起来试试下面的操作吧。

*CommonCmd*
--------------------------------------------------------------------
这里介绍和代码编写相关的常用命令。 其实前面所介绍的set hls, set ic也属于这部分
内容。

*SystemCmd*
------------------------------------------------
首先介绍一些和系统交互的命令。第一个为: >

    :pwd

该命令用于查看当前的窗口的工作目录。目录操作有: >

    :cd your/path

该命令用于切换当前目录到指定的目录下。和shell中的cd一样可以使用tab自动补齐。除
此之外，还有: >

    :lcd /your/path

和cd类似，但只设置当前窗口的当前目录，别的窗口的当前目录保持不变。

当前目录的作用在于，当需要对该当前目录下的文件或目录进行操作时，就不需要输入绝
对路径来访问，可以直接使用相对路径。另外，如果输入命令: >

    :e .

则会在Vim中打开当前目录，其中.就表示当前目录。 此时Vim就表现得像一个文件浏览器
了，只是功能比较简陋点。

如果需要在Vim中直接执行shell命令，例如mkdir来建立一个目录tmp，则可以输入: >

    :!mkdir tmp

即可在当前目录下新建一个tmp目录。 该命令是在要执行的shell命令前添加一个!。这个
和前面介绍过的强制执行类似，只不过强制执行是将!放在命令后面， 而且强制执行的命
令是Vim中的命令，而不是shell命令。

接下来介绍如何对Vim进行配置，调教开始！！

*Color-Scheme*
------------------------------------------------
Vim安装后的默认样子是十分土的，大部分使用者都是因为不能接受Vim的土包子样才弃用
它的。其实Vim是需要进行设置、调教才会变得强大的。 下面就一步一步介绍如何进行设
置，将Vim打造成程序员专用编辑器。

先从界面视觉上着手，其他IDE有的神马语法高亮、自动缩进一个都不能少。

首先选择一个配色方案。所谓配色方案就是在软件里背景色如何、前景色如何、出错信息
颜色如何、状态栏什么颜色等等。Vim安装后自带了很多配色方案在默认安装路径下： >

    - linux: /usr/local/share/vim/vim73/colors/
    - macos: /usr/share/vim/vim73/colors/

colors目录下看到很多配色文件，里面还有个README.txt，有详细的介绍。那么如何将这
些配色方案应用起来呢？ 例如要使用koehler配色方案，则在Vim中键入如下命令: >

    :color koehler

输入后是不是发现Vim整个大变样了。 也可以在键入color之后，可以使用tab键来遍历系
统自带的配色方案，然后进行选择。

Vim的可定制性是超强的。 如果你不满意系统自带的配色方案，完全可以自己编写一个配
色文件，然后放置到该路径下。不过推荐放到自己的目录下：

    ~/.vim/colors/

然后使用color命令导入。

*SyntaxHighlight*
------------------------------------------------
代码编写中的语法高亮是必不可少的。

配色方案只是全局的颜色搭配，而针对特定语言的语法高亮和配色方案不同。例如，在编
写C源文件时，输入static之后，static是关键字，因此需要将该单词高亮显示。 而不同
的语言有着不同的关键字集，且不同的语法高亮文件也有着不同的颜色搭配。要启用语法
高亮，输入命令: >

    :sy on

sy是syntax的缩写，如果你直接输入: >

    :syntax on

是同样的效果，即Vim提供命令的简写。输入: >

    :sy off

则会关闭语法高亮显示。

Vim发行版里带了450多种语言的语法高亮，在其主页vim.org上还可以找到更多。而针对C
语言，你可以到如下网址上下载适合你审美观的语法高亮文件，例如：

    http://vimcolorschemetest.googlecode.com

将下载好的文件保存到：

    ~/.vim/syntax/

目录下，重命名为c.vim即可。 如果读者有兴趣，可以自己修改该文件打造自己风格的语
法高亮。

*LineNumber*
------------------------------------------------
在代码编写和查看中，显示代码的行号是非常实用的功能，代码都是以行为单位嘛。而在
程序开发调试过程中尤其有用：编译器报错打印行号，使用printf调试打印行号，assert
报错打印行号，gdb调试输出打印行号，执行一些组合操作需要行号。

要在Vim中显示行号，输入如下命令: >

    :set nu

之后，便会默认在窗口的左侧显示行号了。nu是number的缩写，两者等效。如果需要关闭
行号，输入: >

    :set nonu

即可。

*Indent*
------------------------------------------------
代码缩进是代码风格中重要的一部分，也是体现程序员专业素质的一个重要指标。值得庆
幸的是，使用Vim来编写代码使得这个工作变得很轻松。

Vim默认对大部分的语言，包括C，都提供了自动缩进功能。如下命令使能自动缩进: >

    :filetype indent on
    :set autoindent

之后，Vim会判断文件类型载入不同的缩进规则。

在编写代码过程中，Vim在每次回车之后，便会自动将光标缩进到合理位置。比如输入{自
动向右缩进一个tab字符(具体用什么缩进可以配置，下面会介绍)，输入}自动回退缩进。
这样就不需要使用者自己输入tab键或者空格键来控制缩进了。更棒的是，Vim会智能地自
动判断缩进层次，这样就不需要自己来看那一层层的嵌套了。

如果是针对已有的代码，想要修改代码的缩进，比较笨的方法就是给每行不符合缩进要求
执行回车，让它回车后自动缩进。不过有更高效的方法。

*ChangeIndent*
-----------------------------
>, <, =

这三个命令一般会放在组合操作中的范围+操作命令里。 例如，如果你要将10行同一层次
的代码向右缩进一级，则可以使用可视行选择需要缩进的代码，然后键入>。 执行后，该
代码块便会向右缩进一级了。而<则是向左缩进一级。 >和<用以表示缩进方向也是十分形
象的吧^_^。

假如你要将10行代码缩进三级呢，那是不是要重复执行三次该操作序列呢？聪明的读者可
能会想要使用宏来完成，但是也必要麻烦。这里有更简单的方法。

*RepeatChange*
-----------------------------
.

该快捷键会重复上次文本的改变。不过该快捷键只是用来重复简单的改变操作，而不能重
复命令行命令。可以将起看作是轻量级的重复，而宏则是完备的重量级重复。

还有=没有介绍呢。 上面介绍的<和>只能让代码(不管是不是同一层次)一起缩进相同的距
离，感觉没那么智能。例如，你面对的是这样的一个函数: >

    int bad_func(int i, int j)
    {
    if(i == 1){
    return i++;
    } else {
    if(j == 1)
    return 0;
    else
    return 1;
    }
    }
    
看着是不是很崩溃，完全搞不清逻辑。当然这是个极端的例子，但是平常还是会碰到一些
缩进层次混乱的代码。那么如何梳理呢，使用<和>是不可行的，要不就每行手动回车吧？
呵呵，高效的方法Vim当然是有的。那就是使用=。

首先移动到函数体定义开始处的{，切换到可视模式，然后键入%将整个函数体选中，之间
就键入=号，执行命令。 哈哈，代码一下子就很乖的各自回到了适当的缩进级别了，很神
奇吧。该函数正常的样子如下: >

    int bad_func(int i, int j)
    {
        if(i == 1){
            return i++;
        } else {
            if(j == 1)
                return 0;
            else
                return 1;
        }
    }

缩进的话题还没有结束。 不同的代码风格要求的缩进字符是不同的，例如Linux内核的代
码风格要求使用tab缩进，并且tab的宽度为8个字符。 这样做的解释是：可以防止程序员
写出嵌套太深的代码。 可以查看Linux内核源码树里Documentation目录的CodingStyle文
件。

那么如何应对不同的缩进要求呢，Vim提供如下设置命令: >

    :set expandtab
    :set tabstop=4
    :set shiftwidth=4

第一个命令使能了用空格代替tab，即使用空格来进行缩进。 默认情况下Vim是使用tab来
缩进的；第二个命令设置了一个tab代表的空格数；第三个命令设置tab键在文本显示时所
显示的宽度为多少字符数。更详细的可以help对应的参数来查看帮助。

*Map*
------------------------------------------------
对于每天面对整屏整屏的代码、需要成天coding的码农来说，提高效率是十分重要的，而
快捷键便是其中一个重要的手段。

在前面的|BasicEdit|中提到过， 对于系统的复制粘帖指令，因为输入序列较长，可以自
定义快捷键将操作序列映射为单个按键。要实现该映射，输入的命令如下: >

    :map <F3> "+y
    :map <F4> "+p

这样的设置，即将复制操作定义为了<F3>键，而粘帖操作定义为了<F4>键。

再例如，在C中经常要注释掉一行代码或者取消行注释。 这当然可以通过I//以及^xx来实
现，不过每次都需要输入不是很麻烦吗？输入如下命令: >

    :map <F11> I//
    :map <F12> ^xx
    :imap <F11> <esc>I//
    :imap <F12> <esc>^xx

便将<F11>定义为了行注释的快捷键，而<F12>定义为了去掉行注释的快捷键了。

那么命令中的imap是什么意思呢。imap表示定义在插入模式下的键映射。 即map所映射的
快捷键只能在普通模式下识别，而imap定义的快捷键则适用于插入模式。即然是插入模式
下，因此该操作序列就需要先执行<esc>操作，回到普通模式下后再执行行注释。 这样的
话进行行注释就可以不用管当下处于什么模式下，直接按下<F11>即可。除了map、imap，
Vim还提供了vmap, xmap等等。

键映射还可以有着十分复杂的设置，比如执行条件判断等等。

*AutoCompletion*
------------------------------------------------
Vim也是支持自动补齐的，不过自动补齐有两个版本。第一种为Vim自带的，自动补齐的候
补选项是文本中已出现的单词，即上下文相关补齐；第二种为通过外部插件来实现的，例
如supertab, neocomplcache等等，可以到Vim官网上查看，应该有很多的。

这里只介绍Vim自带的，最基础而且简单；而对插件的选择则是因人而异，众口难调。

*completion*
-----------------------------
CTRL-p, CTRL-n

例如Vim中同时打开了两个源文件在进行编辑：main.c和login.c。在main.c中定义了变量
status和life，在login.c中定义了stop和list。

在main.c中输入st之后，需要进行自动补齐。此时光标位于st之后，并且仍然是处于插入
模式，键入CTRL-p [previous]或者CTRL-n [next]，则出现一个类似下拉列表的文本框，
列出了符合st开头的单词。这里列出的是status和stop，其中在stop之后会注明该变量是
定义在login.c中的。 再按下CTRL-p或者CTRL-n则用来向上或者向下选择所列出的候选变
量名，选择好之后空格即可。

同样的，在login.c中输入li之后，键入CTRL-p或者CTRL-n， 也会出现选择lift和list的
文本框。

该方法的缺点是：只有Vim中打开的文件，才会被纳入到搜索匹配补齐的范围之内， 而没
有被打开的文件则不会被搜索。这和跨文件查找一样，需要更强大的插件来完成。读者可
以去查找符合你自己要求的自动补齐插件。

*folding*
-----------------------------
zr, zR, zm, zM

关于语法折叠，我自己是不太喜欢的，不过习惯使用IDE的人可能会比较喜欢。 这可以使
得代码非常简洁，容易浏览代码。不过我自己的想法是， Vim已经提供了很强大的motion
指令，可以很方便地在各个代码块之间移动，那么比起需要频繁地使用折叠指令带来的繁
琐操作，我还是宁愿放弃使用语法折叠。

正是因为不怎么使用语法折叠，这里就不多做介绍了，有兴趣的读者可以使用如下的命令
查看帮助，了解更多: >

    :help cindent
    :help autoindent
    :help smartindent

下面再介绍两个小技巧类型的快捷键。

*Man*
-----------------------------
K

man手册是Linux中，无论是命令行使用还是编写程序，都会经常需要查看的手册，对程序
员十分友好。 使用Vim在编写代码过程中，如果对某个库函数或者系统调用不熟悉，需要
查看它的man手册时，可以直接将光标移动到该函数名上，然后键入K， Vim会自动将自己
隐藏，然后调用man程序显示该函数的手册了。

需要说明的是，该功能在终端下使用起来最方便和完美，如果是使用gvim的话，手册中会
出现乱码，影响查看。

*Ascii*
-----------------------------
ga

该命令是查看光标下的字符的ascii码的值，信息会在信息区给出。这个命令可能对于写C
程序，特别是嵌入式的程序比较有用。读者可以尝试下。

*ManageProject*
------------------------------------------------
设想这么个场景：在今天的工作里， 你在Vim中已经打开了几个源文件进行编辑，而且还
使用分割窗口打开了其他目录下的参考文档，以便一边编程一边查看。但是要下班了，需
要关掉电脑，那是不是意味着，明天重新工作时需要再手动地将各个源文件和文档打开，
已恢复到昨天的工作状态呢？

很多IDE则不存在这个问题，它会记住每个工程在关闭时的状态： 打开了哪几个文件，每
个文件当前显示的位置等。

Vim也是提供这样功能的，只不过不是自动完成的，需要用户自行管理。 不过也可以编写
脚本来实现该功能的自动化。这里只介绍工程管理相关的命令。

在你要关闭Vim之前，并且执行了:wa之后，输入命令: >

    :mks

即可将当前编辑会话保存了。这个命令的完整形式是mksession，即“制作会话”。

会话是Linux中常用的一个名词，可以理解为一次工作场景、工作环境。例如登录到Linux
中便可认为是开启了一次会话，而logout便是结束一次会话。

mks会将本次会话信息写入一个Vim脚本，该脚本能够恢复当前的编辑会话。如果命令后面
为空，不提供文件名， 则默认使用"Session.vim"作为脚本名，会在当前目录下生成该文
件。如果当前目录下已有该文件，则需要包含!，来强制执行，将已有的文件覆盖。

保存了会话之后，在第二天需要载入时， 先确保当前目录是所保存Session.vim所在的目
录，然后执行命令: >

    :so Session.vim

来导入会话信息。so的完整命令是source，表示载入会话。 这时Vim便会立刻恢复当初保
存时的文件布局，甚至连当时做的书签标记、记录的宏都还有效。

自此， 对于如何设置Vim，使得代码编写简化和提高效率的介绍到此了。下面插件部分会
再介绍几个用于编程的插件。

*RunCommand*
--------------------------------------------------------------------
嗯，好了，看过了上面的介绍后， 你可以在Vim中输入各种设置命令，将语法高亮、自动
缩进、显示行号等等配置好了，使用后也觉得非常ok，心满意足的关闭Vim。 不过在下次
打开Vim写代码时，你会发现Vim还是默认的那副土样，你上次辛辛苦苦输入的各种设置命
令已经浮云了。难道每次都要输入一堆设置命令吗？

这时便是配置文件发挥作用的时候了。不过，你会感到奇怪，找不着菜单中的“配置”选项
来打开设置对话框啊，事实上，根本连菜单都没有！

大部分IDE或者编辑器都提供了设置对话框来对软件进行配置， 并将配置保存在配置文件
中，在每次打开时载入，保证软件如同你所期望的那样。只不过很少有用户会去打开配置
文件查看，甚至查看不了，因为你找不到，即便找到了也看不懂，因为可能使用的是二进
制保存的，而不是文本形式。

如果读者使用过Total Commander，并且还折腾过的话，应该会对它的配置比较了解。 除
了通过tc软件上的配置对话框来设置之外，你可以在其安装目录下很容易发现它的配置文
件，然后用文本编辑器打开就可以直接在里面编辑设置，因为它是文本形式的，而且注释
很详细。这种方式是十分舒服，在Windows下很少有软件做得这么贴心。

不过在Linux里，大部分软件都是这样的，Vim也不例外了。 Vim的配置文件的修改也十分
简单。

首先确认的一点是，个人的配置文件是放置在用户家目录下的，文件名为.vimrc，即： >

    ~/.vimrc

它的编写很简单：将设置所需要输入的那些命令去掉开头的冒号，然后直接写在配置文件
中，一行一个命令即可。在每行前添加引号来注释。

Vim将在启动时，读取配置文件，将里面的每行配置当作命令输入来自动执行。 这样就不
需要每次手动输入命令来进行设置了，而是由Vim自动完成。是不是很简单易懂。

对Vim的设置就只需要这么一个小文本文件就可以了。如果身边的人想要和你的Vim的配置
变得一样，却不愿花功夫去折腾，那么直接将你的配置文件拷给他，覆盖掉他的用户家目
录下的配置文件即可。

当然除了这个配置文件之外，还记得前面提到的存放各种语法高亮配置文件、缩进配置文
件的路径吗？即： >

    /usr/local/share/vim/vim73/

该目录是Vim安装后默认建立的，里面存放着Vim默认自带的配色方案、语法高亮、缩进规
则、帮助文档、插件、按键映射、拼写检查等等文件。这些是对系统上的所有用户都适用
的文件。而用户自己应该在自己的家目录下有这么个目录，即： >

    ~/.vim/

来存放专用于自己的配色方案，语法高亮文件等等，特别是插件。关于插件的详细介绍，
在后面|Plugin|中。

*FileEncoding*
------------------------------------------------
对于Linux用户来说，需要应对各种编码的文件。Linux下大部分使用的是utf8编码。需要
设置Vim的编、解码来应对不同编码的文件。这里直接给出我在配置文件中的配置: >

    " 文件保存编码 "
    set fenc=utf-8
    " 打开文件编码猜测 "
    set fencs=utf-8,gb2312,ucs-bom,gb18030,gbk,cp936,big5

有两条设置命令。 第一个设置将Vim的默认保存的编码格式设置为utf8格式。第二个设置
则是设置在Vim打开一个文件时，对文件编码进行检查的种类和顺序。 即首先检查该文件
是否为utf8格式，是则直接打开，不是则继续下一个检查，检查是否为gb2312格式，如此
类推。如果都不符合的话，则会打开为乱码。

通过添加该命令后面的编码类型，可以让Vim支持多种编码格式的文件。

如果想要查看当前Vim都设置了哪些的话，可以输入命令: >

    :set

set命令后面不接任何参数，表示查看Vim中的设置，包括是否使能了自动缩进、是否使能
语法高亮、文件编码为什么等等。

当然，配置中还有许多话题这里没有提及， 例如利用Vim自身的脚本语言来条件执行命令
等，读者可以自行查看帮助。

*Plugin*
--------------------------------------------------------------------
插件机制是软件可扩展性的一个体现，很多知名软件都提供扩展机制，Firefox，Chrome，
Eclipse等等。在开源的世界里，一个好软件没扩展你都不好意思和人家打招呼。

这里首先简要介绍一下Vim的插件安装， 然后再介绍对代码编写比较有帮助较有用的几个
老字号的插件(这样异议就没那么多了)。其实插件包含的内容很多，例如插件的编写等，
但是作为一个入门级指南文档，点到为止即可，毕竟不是每个人都是“不折腾会死星人”。

*Taglist*
------------------------------------------------
这里先以taglist插件为例来介绍如何安装插件。 需要说明的是，该插件需要使用下面马
上介绍的|ctags|，来建立标签索引，因此使用该插件前需要安装好该程序。

首先到Vim的官网上(www.vim.org)首页的左侧搜索框中输入"taglist"搜索该插件。Vim官
网上将插件统称为Script，即脚本。其实也确实如此，因为Vim的插件都是使用Vim自身的
脚本语言所编写的，都为脚本程序。下载网址如下：

    http://www.vim.org/scripts/script.php?script_id=273

下载后解压该zip包，发现两个目录，分别为doc和plugin。将这两个目录拷贝到用户家目
录下的.vim目录内，如果已有这两个目录的话，合并即可。

其中，doc目录内存放的是taglist的帮助文档， 文档格式和Vim的帮助文档格式一致，都
可以进行跳转。安装之后，你可以在Vim中输入: >

    :help Tlist

来查看taglist的该帮助。

而plugin目录内存放的则是插件的脚本文件了，将其拷贝到对应目录后就完成了插件的安
装。就这么简单。

安装之后，需要重新打开Vim。在里面打开一个C源文件，然后键入: >

    :Tlist

默认会在右侧新开一个窗口，里面列出了源文件中所定义的宏、变量和函数。切换到该窗
口上(|ShiftWindow|操作)，移动光标到想要查看的函数名之上，然后键入回车， 便会在
跳转到源文件中该函数定义的地方了。

对于我来说，该插件使用的较少， 因为Vim本身的搜索功能和gD跳转功能已经够用了。

taglist最大的优点是：它的跳转是跨文件跳转，这是gD所不具有的。例如，你Vim中打开
了main.c和login.c在编辑。打开taglist，它的窗口会显示这两个源文件中的所有定义。
假设此时你在main.c标签页下编辑，然后在taglist中移动到了login.c中的一个函数定义
上，并键入回车，则当前标签页会关闭main.c而打开login.c并跳转到该函数定义处。 这
便是跨文件跳转。如果想要跳转回去，键入CTRL-o即可。

要关闭taglist窗口，再次执行:Tlist即可。taglist的具体用法请查看它的帮助。

*ctags*
------------------------------------------------
另外一个支持跨文件跳转的插件是ctags。其实这不是一个插件，而是Linux下的一个应用
程序。在安装好ctags之后，在Vim中执行: >

    :!ctags *.h *.c

便会在将当前目录下的所有h和c文件里的各种声明和定义进行检索，并在该目录下生成一
个索引文件tags。

*TagsJump*
-----------------------------
CTRL-], CTRL-o

Vim默认使用该文件作为索引。还是上面那两个文件，你在编写main.c时，调用了login.c
中的login()函数，如果你想查看该函数定义，不需要繁琐地去打开taglist窗口，然后移
动到该函数名处按回车了。只需将光标移动文件中该函数名上，然后键入CTRL-]，便会和
使用taglist的效果一样。 同样，如果查看过后需要返回，则键入CTRL-o即可。

关于ctags在Vim中的应用和帮助信息，可以输入: >

    :help ctags

*quickfix*
------------------------------------------------
最后要介绍的一个插件是quickfix。 不过到7.3版时，该插件因为太好用而已经被吸收到
了Vim内部，用C来实现，不需要再额外下载安装插件。

quickfix也程序员的好工具之一。 在终端下编写代码时，你是不是常常需要在Vim和终端
之间切换呢？总需要CTRL-z先后台Vim，然后执行make。 如果出错了，先看第一个编译错
误提示的行号，然后fg调出Vim，执行跳转命令后修复该错误。 然后再CTRL-z，继续这些
操作直到编译没有错误为止。

这样很烦的吧。不过有了quickfix之后，你就可以和这种造成你左手小拇指抽筋的生活说
再见了。

当要编译时，你只需直接在Vim中执行: >

    :make

即可。有人问了，难道make前面不需要加!嘛。 呵呵，不需要的，该命令和在终端下执行
make一样，除此之外，Vim还会把产生的编译信息截获并进行整理分析。回到Vim之后，如
果没错，那么你即可以不用后面的动作了，如果有编译错误需要修复，则执行: >

    :cw

cw [check-window] 执行后会在当前窗口的下方新建一个新窗口，然后将刚才执行make得
到的所有编译错误和警告信息都输出在该窗口内，如同Visual Studio和Delphi里面一样。

不过比VS和Delphi更方便的是，你是不需要使用鼠标来一个一个点击错误信息，然后跳转
到对应的错误行。你只需要输入: >

    :cn
    :cp

就可以在所列出的error和warning之间跳转，光标会直接跳转到源文件中的那行代码上。
直到你修改完毕之后， 再次执行:make，quickfix窗口内的信息会自动更新，然后重复以
上操作，直到所有编译error和warning消失。

要退出quickfix窗口的话，你可以把它当作普通的窗口，使用:q来退出，也可以直接再次
执行:cw来退出。

是不是十分方便，如果quickfix的名字一样，可以快捷地修复error和warning。

自此，对于插件的介绍，特别是编程相关插件的介绍即到此为止了。 Vim拥有数量巨大的
插件可供选择，并且对不不同的语言有着不同的插件，用处也不尽相同，读者可以到官网
上自行查找安装。

值得注意的是，Vim在每次开启后会载入plugin内的插件脚本。 因此如果安装插件过多的
话，Vim的启动速度会明显变慢，这和Firefox是一样的。


*Summary*
==============================================================================
本文档到此结束了，基本上介绍到了Vim使用中的需要涉及到的基本范围。当然，Vim中还
有着其他的功能没有介绍， 比如：Vim脚本语言、缩写替换、对其他语言的接口、diff操
作、二进制模式、拼写检查、文件加密等等。所有没有提及到的方面，读者可以查看相关
书籍以及自带的帮助文档。

关于Vim使用的技巧，可以到官网上查看vim tips wiki。

Vim的拥趸如此之多，以至于恨不得在所有的软件上都能像Vim那样操作该软件。当然，如
果该软件的扩展性好的话，完全是有可能的，比如Firefox的vimperator、pentadactyl，
比如chrome的Vimium，比如kscope的Vim模式，甚至有人给visual studio也写了个插件以
支持Vim方式的操作来编写代码。

本文档也是使用Vim编写的。使用Vim写东西是十分快乐的一件事。

希望读者能够通过本文档能够熟练操作Vim，理解它的强大和设计理念，并喜欢上它。 如
果在本文档中发现了错误或者有建议，可以email我：zhssmail@gmail.com， 我会积极改
进。


*Reference*
==============================================================================
Vim官网
http://www.vim.org

Vim的中文帮助文档
http://vimcdoc.sourceforge.net/

维基百科
http://zh.wikipedia.org/zh-cn/Vim

博客 - 手把手教你把Vim改装成一个IDE编程环境(图文)：
http://blog.csdn.net/wooin/archive/2007/10/31/1858917.aspx

博客 - 普通人的编辑利器——Vim
http://blog.sina.com.cn/s/blog_46dac66f010005kw.html

博客 - 程序员的编辑器——VIM
http://www.pconline.com.cn/pcedu/soft/gj/photo/0609/877033.html


*VimVersion*
==============================================================================
:version
VIM - Vi IMproved 7.3 (2010 Aug 15, compiled Nov  5 2014 21:00:28)
Compiled by root@apple.com
Normal version without GUI.  Features included (+) or not (-):
-arabic +autocmd -balloon_eval -browse +builtin_terms +byte_offset +cindent
-clientserver -clipboard +cmdline_compl +cmdline_hist
+cmdline_info +comments -conceal +cryptv +cscope +cursorbind +cursorshape
+dialog_con +diff +digraphs -dnd -ebcdic -emacs_tags +eval +ex_extra
 +extra_search -farsi +file_in_path +find_in_path +float +folding -footer
 +fork() -gettext -hangul_input +iconv +insert_expand +jumplist
 -keymap -langmap +libcall +linebreak +lispindent +listcmds +localmap -lua
 +menu +mksession +modify_fname +mouse -mouseshape -mouse_dec
 -mouse_gpm -mouse_jsbterm -mouse_netterm -mouse_sysmouse +mouse_xterm
 +multi_byte +multi_lang -mzscheme +netbeans_intg -osfiletype +path_extra
  -perl +persistent_undo +postscript +printer -profile +python/dyn -python3
  +quickfix +reltime -rightleft +ruby/dyn +scrollbind +signs
  +smartindent -sniff +startuptime +statusline -sun_workshop +syntax
  +tag_binary +tag_old_static -tag_any_white -tcl +terminfo +termresponse
  +textobjects +title -toolbar +user_commands +vertsplit +virtualedit +visual
  +visualextra +viminfo +vreplace +wildignore +wildmenu +windows
  +writebackup -X11 -xfontset -xim -xsmp -xterm_clipboard -xterm_save
     
system vimrc file: "$VIM/vimrc"
user vimrc file: "$HOME/.vimrc"
user exrc file: "$HOME/.exrc"
fall-back for $VIM: "/usr/share/vim"
Compilation: gcc -c -I. -D_FORTIFY_SOURCE=0 -Iproto
-DHAVE_CONFIG_H -arch i386 -arch x86_64 -g -Os -pipe
Linking: gcc -arch i386 -arch x86_64 -o vim -lncurses

# vim: set filetype=help:
