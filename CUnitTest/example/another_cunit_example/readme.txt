/*
 * 对该单元测试示例代码的一些说明
 *
 * 官网为：http://cunit.sourceforge.net
 * CUnit的版本为：CUnit-2.1-2-src.tar, Release Date: 2010-10-17 
 *
 * 2010年11月22日 星期一 14时01分54秒
 * zhs@lab601
 */

另外一种代码组织方式。

概述
------------------------------------------------------------------------------
该项目用作CUnit测试的示例代码，说明了如何在具体项目中使用CUnit进行单元测试。具
体、详细的CUnit使用方法参考相关文档资料。

该项目的根目录下有一个Makefile文件、src子目录和unit_test子目录。Makefile文件用
于执行各种不同的目标；src目录存放实际的项目代码(也称为产品代码)；unit_test目录
存放针对src中项目代码的单元测试代码。 src和unit_test目录下有各自的Makefile，以
便管理各自的源码目标。

这样的项目目录组织方式将项目代码和测试代码放置在不同的源代码树下，进行了隔离，
避免了项目代码和测试代码相互的混淆。通过Makefile中恰当地设置，让测试代码能够调
用项目代码中的函数，从而进行单元测试。值得注意的是，对组织项目代码和测试代码来
说，这只是其中一种方式，还存在着其他类型的组织方式。但是，无论采用那种方式，在
一个项目中，每个成员使用的方式都要保持一致，不能混用。

src目录
------------------------------------------------------------------------------
src目录下文件有(如未特别说明，均指的是未编译的情况下)：
    main.c main.h maxi.c maxi.h mini.c mini.h Makefile

其中maxi.*和mini.*表示两个模块，一个计算最大值，一个计算最小值。对应的.c文件为
其实现，.h文件为接口文件。出于演示单元测试的目的，这里只是简单定义了两个函数，
分别返回最大值和最小值，并在头文件中进行接口函数的声明。

main.*为主模块，是另外两个模块的调用者，为应用程序的入口点。这里没有将main模块
进行单元测试。

Makefile为项目代码的Makefile文件。在该文件中定义了几个目标。有些目标是顶层目录
中的Makefile能够调用的，有些则不是。

all是伪目标，依赖的目标是$(EXEC)。 为了生成$(EXEC)，首先编译产生各个依赖模块的
目标文件(由目标$(OBJS)实现)， 然后将这些目标文件以及需要链接的库文件(由$(LIBS)
指定)编译成可执行文件。 注意，这里没有清理各个模块产生的目标文件，因为这些中间
目标文件可能会被单元测试代码调用。这也说明了，想要运行单元测试程序，首先必须要
编译出应用程序。 模块目标文件由$(OBJS)指定，如果日后项目代码中模块文件有增加或
删除，需要对该变量进行修改。

$(OBJS)目标为显示规则声明，替换了隐含规则。 该目标用于将每个模块的源码编译出对
应的目标文件。这里的主要目的是强制要求了每个模块对应的.c文件都必须要有.h文件，
否则会报错。

ar是伪目标，依赖的是$(ARLIB)目标。执行的命令是将指定的目标文件打包成$(ARLIB)指
定的库。$(AR_OBJS)指定了需要被编译成库的目标文件。如果要增减库中所包含的模块，
需要对该变量进行修改。

app目标则是单纯的运行应用程序。因为该目标依赖$(EXEC)，因此如果执行该目标时没有
生成$(EXEC)，make会首先自动地去编译生成可执行文件$(EXEC)，然后再运行应用程序。

install目标本意是安装应用程序，例如把可执行程序拷贝到某个目录下。 目前除了打印
一条语句外没有任何动作。

clean目标则是用于清除编译过程中产生的所有中间文件，比如目标文件，库文件等。 执
行之后，目录即处于未编译的最初状态。

unit_test目录
------------------------------------------------------------------------------
unit_test为单元测试目录，只存放单元测试相关代码。该目录下的文件有：
    test_main.c test_main.h test_maxi.c test_maxi.h test_mini.c test_mini.h
	Makefile

针对项目代码中的每个需要测试的模块，该目录下有着对应的测试模块代码。一般来说，
整个单元测试对应一个registry实例，一个registry中有一个或多个suite； 一个测试模
块代码对应着CUnit中的一个suite实例， 一个或多个suite用于测试项目代码中的一个模
块，一个suite里有一个或多个test(即test case)实例；一个test的代码实体即为一个测
试函数，一个或多个测试函数用于测试项目代码中的一个函数；每个测试函数中包含一个
或多个断言，每个断言调用被测试函数，取得结果进行测试。

在这个例子中，测试代码中的test_maxi模块用于测试项目代码中的maxi模块， 同样的，
test_mini对应mini模块。下面介绍一下test_maxi的结构，test_maxi和test_mini结构类
似，不再赘述。

test_maxi.c定义了具体的测试函数、所需结构体以及添加suite的接口函数。其中测试函
数包括testIQJ()、testIGJ()和testILJ()。这三个测试函数表示三个test case，用以测
试maxi模块中的maxi()函数。随后定义了testcases数组，将这三个test case添加到数组
中。testcases数组随后准备添加到suite中。

suite_success_init()和suite_success_clean()为一个suite的初始化函数和清理函数，
具体的作用可以参考相关资料，这里只是简单地返回零值，表示调用成功。随后定义了一
个suites数组，数组元素为该测试模块将要注册的suite。因为test_maxi模块只注册了一
个suite，因此suites只有一个元素。suite包含的test case即为上面testcases数组定义
的三个test case。

最后定义了test_maxi_AddSuites()，作为模块的接口函数。 在主调模块中被调用之后，
向CUnit注册添加该模块中定义的test suite及对应的test case。当测试运行时，CUnit
便会执行该模块下的测试。 该函数首先断言CUnit测试框架已经初始化成功，如成功则继
续调用CU_register_suites(suites)将suites中的suite进行注册添加。 该函数同时在对
应的头文件中进行了接口声明。

至此便完成了对项目代码中maxi模块的测试用例(test  case)和测试包(test suite)的注
册添。当主调模块调用模块的接口函数后，对应的测试便会加入到框架中了。

test_main为单元测试的主调模块。主要负责初始化CUnit框架，然后调用各个测试模块提
供的测试包添加接口函数添加各种测试，之后设置运行的接口，最后运行测试。在测试运
行完成后进行释放清理工作。可见，该模块和项目代码中的main主模块没有关系。如果想
对项目代码中的main模块进行单元测试，则需要再编写一个测试模块。

CUnit提供了四种模式的接口，分别为automated、basic、console和curses，这里分别给
出了设置和运行代码，用条件宏进行选择。注意，使用默认编译选项编译CUnit后， 笔者
发现并没有提供curses功能，可能需要在configure时进行参数设置。 每个接口的差别可
以查看相关文档。

Makefile为项目代码的Makefile文件。在该文件中定义了几个目标。有些目标是顶层目录
中的Makefile能够调用的，有些则不是。

all是伪目标，依赖目标是$(EXEC)。为了生成$(EXEC)， 首先需要编译产生各个模块的目
标文件(由目标$(OBJS)实现)，然后将这些目标文件以及库文件编译成可执行文件。 各个
模块目标文件由$(OBJS)分别指定生成，如果项目代码中模块文件有增加或删除， 需要对
该变量进行修改。

另外，因为测试代码各个测试模块调用了项目代码中对应模块中的函数，因此在最后测试
程序生成过程中需要链接项目代码模块的目标文件，这点在上面提到过。但是因为测试代
码和项目代码位于不同的目录下，测试代码编译时不能自动地寻找到所需目标文件。这里
的解决方法是在指定$(EXEC)的依赖目标时，不仅依赖$(OBJS)所指定的测试代码目标，也
依赖$(EXE_OBJ)所指定的项目代码的各模块目标文件。并且在编译命令中通过自动变量%^
将所有依赖目标都添加到编译命令中，这样就能够顺利编译通过了。$(EXE_OBJ)是通过指
定目标文件的路径来定位的。当项目代码中模块发生变化，且需要测试时，对Makefile来
说，就需要修改$(EXE_OBJ)和$(OBJS)两个变量，以保证编译通过。

此外，因为测试程序依赖项目代码中的模块，所以如果项目代码没有编译，而要求首先编
译测试代码时，make会根据依赖规则首先生成$(EXE_OBJ)指定的目标文件，满足测试程序
需要的条件后再生成测试程序。

$(OBJS)目标为显示规则声明，替换了隐含规则。 该目标用于将每个模块的源码编译出对
应的目标文件。这里的主要目的是强制要求了每个模块对应的.c文件都必须要有.h文件，
否则会报错。

test目标则是单纯的运行测试程序。因为该目标依赖于(EXEC)，所以如果没有应用程序的
可执行文件，make会首先自动生成可执行文件，然后再运行应用程序。

install目标本意是安装应用程序，例如把可执行程序拷贝到某个目录下。 目前除了打印
一条语句外没有任何动作。

clean目标则是用于清除编译过程中产生的所有中间文件，比如目标文件，可执行文件等。
执行之后，目录即处于未编译的最初状态。

顶层目录
------------------------------------------------------------------------------
顶层目录下除了src和unit_test目录外，还有一个顶层Makefile，也叫做主控Makefile。
它的主要作用是调用各子目录下的Makefile，实现具体目标。

该Makefile中定义了一个函数，接收目标参数，然后遍历每个子目录，调用make执行参数
指定的目标。该函数用于执行各个子目录Makefile所定义的共有目标。变量$(SUBDIRS)指
定了各个子目录，目录定义的顺序为遍历顺序。

all, install ,clean三个目标为调用每个子目录下的make执行对应的目标。

app目标是进入到src目录，执行make app命令，以运行应用程序。

test目标是进入到unit_test目录，执行make test命令，以运行测试程序。

这样编写的主控Makefile使得使用者不必进入到对应的子目录内，即可执行相应的目标。
如果有新的目标，则在对应子目录的Makefile中进行添加，如果需要提出给主控Makefile
调用，则在主控Makefile中添加即可。

小结
------------------------------------------------------------------------------
这个示例程序简单地演示了如何使用CUnit对C程序进行代码测试以及如何管理测试代码。
如前面所说，这种代码组织方式只是众多方式中的一种，应该存在更高效、清晰的组织方
式。 同样的，例子中对CUnit的使用和理解也是众多方式中的一种，官方文档也并未给出
一个推荐的方式。除此之外，该示例程序只演示了对简单逻辑函数的单元测试，对于复杂
的函数实现和模块架构并未做说明，这还需要读者阅读相关资料，并在实际项目实践中不
断加深对CUnit和单元测试的认识和理解，并对该文档进行有效地修正和补充。

对于项目工程中如何具体地编写和管理单元测试，可以参考关于笔者的另一篇单元测试的
文档。

参考资料
------------------------------------------------------------------------------
- CUnit官网示例程序：http://cunit.sourceforge.net/example.html
- 网友博客：http://blog.csdn.net/cwmbecoming/archive/2007/10/19/1832395.aspx
- CUnit官网用户指南文档：http://cunit.sourceforge.net/doc/index.html
  笔者对该文档进行了中文翻译，可以在实验室armftp中找到：
  ftp://down:down@armftp/work/unit_test/CUnit_user_guide_20101122.txt
  其中armftp的地址，在内网里是192.168.0.188，在实验室网段内是172.20.69.133。
- Makefile中文教程.pdf，可以在armftp中找到：
  ftp://down:down@armftp/work/doc/Makefile中文教程.pdf
- 《单元测试之道》，Andrew Hunt、David Thomas 著，陈伟柱、陶文 译。
