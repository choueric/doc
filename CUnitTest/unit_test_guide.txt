/*
 * 通过看书和上网所了解的对单元测试的看法
 *
 * 因为没有进行过单元测试，更多的是对各种信息的收集和整理
 * 基本的框架和绝大部分内容来自《单元测试之道》。
 *
 * 2010年11月23日 星期二 16时52分57秒
 * zhs@lab601
 */

目录：
- 什么是单元测试
- 为什么要用单元测试
- 如何进行单元测试
- 如何做好单元测试
- 设计相关
- 遗留代码
- mock对象
- 小结
- 参考资料


什么是单元测试
------------------------------------------------------------------------------
来自wiki百科里的解释是：
"""
在计算机编程中，单元测试(又称为模块测试)是针对程序模块(软件设计的最小单位)来进
行正确性检验的测试工作。该单元是应用的最小可测试部件。在过程化编程中，一个单元
就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类(超类)
、抽象类、或者派生类(子类)中的方法。

通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后
很可能要进行多次单元测试，以证实程序达到软件规格书(en:Specification)要求的工作
目标，沒有bug；虽然单元测试不是什么必须的，但也不坏。

每个理想的测试案例独立于其它案例；为了测试时隔离模块，需要经常使用stubs、 mock
或fake等测试马甲程序。单元测试通常由软件开发人员编写，用于确保他们所写的代码符
合软件需求和遵循开发目标。它的实施方式可以是非常手动的(透过纸笔)，或者是做成构
建自动化(build automation)的一部分。
"""

从代码角度看，单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、
很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件(或者场景)下
某个特定函数的行为。执行单元测试，是为了证明某段代码的行为确实和开发者所期望的
一致。

单元测试之所以叫这个名字，是因为这些测试针对的目标是项目代码中的独立单元。针对
每个需要进行测试的单元有着对应的测试代码，当测试代码覆盖到整个项目代码时，整个
项目代码都会被测试到。

从工程角度看，单元测试大体上是一个工具，一个和编辑器、开发环境、编译器等处于同
一地位的工具。使用这个工具能够保证代码的正确性以及获得其他好处。

单元测试只是软件开发过程中需要进行的众多测试中的一种，它的作用只是验证一小段代
码是否符合程序员的预期。除了单元测试之外仍然需要对件进行其他类型的测试，比如集
成测试、功能测试、性能测试、环境测试、有效性测试、正确性测试、正规分析等等。

单元测试是针对开发人员的测试，而不是针对测试人员的。也就是说，代码编写者需要自
己编写单元测试代码来进行单元测试的工作，以便验证自己所写的代码与期望是否一致。
而其他类型的测试则由专门的测试人员完成的。对于程序员来说，在编写代码的过程中进
行单元测试时，是不会也不需要考虑整个系统的组装和测试的。


为什么要用单元测试
------------------------------------------------------------------------------
单元测试是一项很重要的技术。它能够在程序员编写代码的同时，提供及时和真实的反馈
。遗憾的是，许多开发人员对单元测试并不十分了解，没有意识到它可以令开发工作变得
更加轻松(而不是更加复杂)。

单元测试不但能保证你的函数逻辑功能正确，也能改变你的设计，使之变得更好，甚至可
以大大减少你花在调试或者重构上的时间。

单元测试与极限编程(XP)密切相关，并和代码审查(code review)一起， 是保证项目代码
健康发展的两个利器。

首先，进行单元测试能够让程序员编写代码的同时，得到及时和真实的反馈。当你写完一
段代码之后，如果对自己自信的话，会对这段代码没有任何疑问，否则可能会对其正确性
有所疑虑。事实上，即便是自信并且老练的程序员，偶尔也会写出有问题的代码。这时如
果进行单元测试， 并以实际的测试结果表明这段代码是没有问题(至少是在进行过的测试
内容之下没问题，取决于编写的测试)，或者立刻告诉你出现了问题以及问题在哪里。 无
论那种结果，你都对你所写的那段代码有个底，可以放心地继续编写其他功能代码或者静
下心来处理掉代码中的bug。

在一个稳定的软件代码上添加新的功能，可能会引入新的bug。 这需要进行测试，保证新
做的修改没有对以前的代码造成损害，并且自身也没有bug。如果无视引入的bug而继续开
发的话(可能你会以为傻子才会这么做，但是在实际项目中， 由于种种原因，确实是有人
这么做的)，最后可能会导致整个项目系统的崩溃，并且没人能够修复。

为了增加一个新功能或者修复一个错误，你对已有的代码进行了修改。假设你能够保证新
增的函数代码是没有问题的， 但是你怎么保证新代码没有不小心地进入新的bug、没有对
已有代码造成破坏呢？如果此前你已经有了单元测试代码的话，你可以运行已有的单元测
试，并把对新代码的测试加入。运行这样的回归测试，使得你能够安心的继续前进。

对底层的代码的修改，可能会导致对几乎所有代码的一连串改动，从而使修改越来越多，
也越来越复杂，当复杂程度变得不可控时，整个项目便会以失败告终。所以，保证已有代
码的正确性，对于整个项目来说是至关重要的。而单元测试是能够提供这方面的帮助的。

避免那种“前进一步，后退两步”的开发方法，保证开发过程保持稳定的步伐前进。即使前
进的速度不快，但至少一直是在前进中，而没有发生倒退。如果遇到了倒退，特别是因为
某个低级错误造成的倒退，会让你自己或整个团队非常沮丧，严重影响士气。

同时，你的单元测试代码不仅对你自己有效果，对团队中的其他人也有效果。利用单元测
试，让你的项目代码能够重复、有效和精确地进行测试。通过了单元测试，意味着这样一
个事实：你的代码从局部性来说没有问题(当然前提是单元测试覆盖率较高)。用事实说话
比你的言语说明或者烦复地解说代码更有效、更直接。而这就依赖于单元测试的可重复性
和一致性。

一边编写代码一边编写单元测试，甚至是在开始编写实际项目代码之前便根据需求编写测
试代码，这样的工作方式，能够让你在考虑如何编写代码时考虑到如何使代码易于进行单
元测试，例如考虑函数的功能专一化、健壮性、重复代码的使用等等。通过单元测试的编
写可以影响你的代码设计，使得代码具有更好的结构和可维护性。关于这个话题在后面的
章节中有具体详细的说明。

面向单元测试的编程，使得程序员能够从测试的角度考虑代码的编写。特别是对代码的错
误异常处理方面的考量。代码出现异常原因很多，硬盘没有剩余空间，网络掉线，缓冲区
溢出等。你在编写单元测试时考虑到的异常情况和极限情况，同样会影响到你编写代码时
对代码设计，会更多考虑到对这些异常的处理，从而让代码变得更健壮。你不能这样来测
试一座桥梁：在风和日丽的某天，仅让一部车顺利地开过这座桥。

对单元测试而言，一个最让人高兴的意外收获是，它能够帮助你充分理解代码的用法。从
效果上而言，单元测试就像是能执行的文档，说明了在你用各种条件调用代码时，你所能
期望这段代码完成的功能。项目成员能够通过单元测试来找到如何使用你所写代码的例子
。并且如果他偶然发现一个你没有考虑到的测试情况，他也可以很快地知道这个事实：你
的代码本身可能也并不支持这个用例。

最后，单元测试是容易并入项目自动化的。通过脚本或者其他方式，单元测试能够自动地
进行，并且给出详细的结果报告。这相对于每次人工的对各个函数进行测试以及用肉眼查
看每次的测试结果来说，大大地提高了效率和准确性。

以上大概的讲述了在项目中使用单元测试带来的一些好处。当然，程序员中会有人认为只
有项目代码才是最重要的，测试什么的没有必要这么认真。以下是可能的一些不愿意做单
元测试的借口(后面紧跟着就是我们的辩解^_^)：

- 编写单元测试太花时间：
  这是初学者最常用的借口。事实上，在项目开发过程中，花费时间最多的是什么地方？
  或者有如下的几个问题：
  - 对于所编写的代码，你在调试上花了多少时间？
  - 对于以前你认为正确的代码，而实际上这些代码却存在重大的bug，你花了多少时间
    在重新确认这些代码上面？
  - 对于一个别人报告的bug，你花了多少时间才找出导致这个问题的源码位置？
  对于没有使用单元测试的程序员来说，上面这些问题所耗费的时间随着代码量的增加和
  项目的深入，所花时间的增加的速度是十分惊人的。
  而采用单元测试的话，可以很大程度地减少这些时间，控制复杂度的增长。这不仅仅是
  因为单元测试能够迅速执行和定位bug， 也是因为为了进行单元测试而对软件架构做的
  变化使得软件的可维护性和可调试性有了大的提升。

- 运行测试的时间太长：
  事实上，在项目实践中，特别是小中型项目中并不是特别关键的因素。即便单元测试代
  码的编写是更多考虑易读性和完备性而不考虑效率的，但是对于中小型项目来说，测试
  执行起来也是很快的，至少比起人工调试来说快得多了。
  而对于大型项目，则需要考虑将耗时的测试和不耗时测试分开。不耗时测试可以经常执
  行，而耗时测试则以较少频率执行。
  另外，对于大型项目来说，部署了自动化构建之后，是不需要程序员自己去参与到测试
  过程中的，一切都由构建服务器完成。程序员可以将精力放到更值得关注的事情上。

- 测试代码不是我的工作：
  这是一个很让人无语的理由。对于那些没有把握的代码，随便地签入到版本库中或者交
  给负责整合和测试的人，这样做是非常随便且没有专业素质。实际上，你也没并有完成
  你自己的工作。一句话，自己的代码自己负责。

- 代码都编译通过了；
  这和“测试不是我的工作”的借口一样。代码通过编译并不代表你的工作就此结束。

- 没有系统运行的真实环境：
  这个特别在嵌入式开发中很明显。对于驱动程序来说，没有实际硬件是不能进行有效的
  调试。但是这种调试是单元测试吗？如果需要在真实环境下运行的测试，就已经不属于
  是单元测试的范畴了，而是其他类型的测试了。
  作为单元测试，你可以在自己的开发机上进行，使用自己的替代方案：编写mock对象，
  或者花一点时间编写模拟环境。

- 我也不清楚代码的行为，所以也就无法测试：
  好吧，如果都不知道代码的行为是什么，那怎么写正确的代码？

测试不可能抓到所有的程序错误，单元测试也不例外。按定义，单元测试只测试程序单元
自身的功能。因此，它不能抓到集成错误、性能问题、或者其他系统级别的问题。单元测
试结合其他软件测试活动更为有效。与其它形式的软件测试类似，单元测试只能表明测到
的问题，对于未测试到的错误则不能做出确定的结论。这便需要提高单元测试的覆盖率和
完备性。


如何进行单元测试
------------------------------------------------------------------------------
单元测试一般都是基于一个单元测试框架来进行的。和自己编写测试框架比起来，这样做
不仅使得测试代码重用性更好，而且利用已有的框架可以很方便的添加各种测试，获得详
实的结果报告。

工欲善其事，必先利其器。首先需要选择一个合适的单元测试工具。单元测试最初是Java
开发程序员中盛行的，JUnit是单元测试框架的鼻祖。 对于C++开发来说，CPPUnit也是事
实标准了。

本文档主要说明的是嵌入式C语言开发中的单元测试，因此没有讨论面向对象。C语言因为
是面向过程而非面向对象，因此在框架结构上并没有多少可从目前主流单元测试的框架中
有所借鉴，因此单元测试工具并没有很多或很强大。常用的C下单元测试工具有：

- CuTest：CuTest(Cute Test)是一个非常简单的C语言单元测试工具。在使用它的时候，
  只需要包含两个文件“CuTest.c CuTest.h”，然后就可以写测试用例，进行测试了。 它
  对用例几乎没有管理功能，报表输出也非常简单，可以用来试验单元测试的基本想法。

- CUnit：CUnit是一个轻型的C语言单元测试框架。它提供了设计、管理、运行测试用例
  的功能。它的报表功能比较强大，但是比较麻烦，更适合于较大一些的项目。

- Check：不错的工具。

- Cmockery：google提供的，光是google的名头就够了吧。支持mock对象。

这里使用CUnit作为单元测试框架做讲解。关于CUnit的详细资料可以查看它的主页：
    http://cunit.sourceforge.net

网站上有源码下载、文档以及示例程序。同时，实验室内有官方文档的翻译稿以及一个较
为详尽的示例程序。

在使用面向过程方式编写程序时，程序员通常会把实现相同功能的代码放在一起，做成一
个函数；将一个或几个逻辑功能独立并且相似或相关的函数组织在一个文件当中，构成一
个模块，即使用“文件”这个硬概念来组织逻辑代码。当程序需要使用已经定义的函数时，
只要将需要的文件include进来就可以了。 在做这样的单元测试时我们只要编写一段客户
代码，然后调用相关文件中的函数。通过定义不同的前置条件，就可以验证每个单元是否
符合预期要求。

如果系统通过了单元测试，却在集成的时候出现问题，大多数情况下是接口实现出现了错
误，测试的重点往往集中在集成测试部分而不是单元内部实现。

目前对于C下单元测试的资料不多，可给出的实例也比较少(反正我是google了很久，没有
看到很多有用的资料)，因此需要我们一步一步在实践过程中找出和总结出在C下应对各种
单元测试情况的方法和方案。

但是，这只和具体实施细节相关。单元测试中的大部分概念和知识无论是在哪种语言中都
是通用的。 文档首先讲述一些通用的概念，再讲解C语言下单元测试的具体细节、难点和
需要注意的地方。

为了对函数调用结果进行判断以及向测试者提供反馈信息， 一般在C语言中常用的方法是
使用断言(assert)宏。使用的方法如下：

    assert(condition);

该断言语句表示期望condition语句为真。 如果为假，assert()会输出断言失败信息到标
准错误输出，并且立刻调用abort()退出程序。其中condition可以为一个表达式或者有返
回值的函数调用。例如：

    assert(i);         //断言i为真
    assert(i == j);    //断言i等于j
    assert(IsOdd(i));  //断言IsOdd()返回值为真

assert()在程序调试中应用非常广泛，详细的使用请查看相关资料。

事实上单元测试就是基于断言的。因为单元测试的本质就是验证代码的行为是否与期望一
致，因此断言便可以用来比较实际代码运算结果和你的期望值是否相等，以此判断代码实
现是否正确。

但是，单元测试并不只是断言这么简单。单元测试框架在断言的基础上做了其他很多的工
作，例如收集断言失败信息、提供接口以方便添加测试用例、提供交互界面、提供用于隔
离每个测试的setup()/cleanup()机制等。 因此使用框架可以方便和清晰地对项目代码进
行单元测试。 事实上，个人也是很容易设计出自己的测试框架的，很多C下的轻量级测试
框架代码量都不是很大。

对比C中的断言，测试框架提供了更多类型的断言来满足不同的应用需求。 对于不同的框
架，在断言失败时，有些会立即终止程序运行，有些则会终止该断言并记录测试失败信息
然后继续执行其他测试，并在最后给出测试结果报告。CUnit提供了普通的断言和FATAL版
的断言，分别满足了这两种情况。具体的使用请参考CUnit的用户指南文档。

使用单元测试的基础便是知道如何使用测试框架提供的各种断言。但是编写测试代码并不
是只是写断言就可以了。测试代码必须要做以下几件事：

- 准备测试所需要的各种条件和资源；
  一般在测试用例的setup()函数中实现。

- 调用要测试的方法；
  传入测试参数，调用被测试函数，取得相应的输出结果。

- 验证被测试方法的行为和期望是否一致；
  使用断言，判断结果与期望是否一致。一个测试函数中可能包含多个断言，但这一组断
  言一般都是有内在关联的，比如是对一个函数的多种边界条件的输入测试。

- 完成后清理各种资源：
  一般在测试用例的cleanup()函数中实现。和setup()配套使用，实现测试用例之间的隔
  离。

那么何时进行单元测试呢？在以下的几种情况下应该执行测试：

- 编写新的函数：编译并运行本地的单元测试。

- 修正bug：运行测试来让bug现形，修正并再次进行单元测试。

- 每次成功编译之后：运行本地的单元测试。

- 每次对版本控制的签入：运行所有的模块或者系统的单元测试。

第一种情况，前面已经提到过了，编写单元测试是程序员自己的工作，应当是一边编写项
目代码一边编写对应的单元测试代码，一边推进项目进度一边完成代码的测试。如果等到
项目快结束时进行单元测试，那几乎是不可能实现的。

第二种情况，如果在通过了单元测试的已有的代码中发现了bug，需要做的事情包括：

- 验明bug。

- 编写一个将失败的测试来证明bug的存在。

- 修正代码，让测试通过。

- 验证所有的测试仍然可以通过，即你没有在修复该bug时损坏其他的测试。

- 同时注意相同的bug会在其他地方发生吗？

通过这样的过程，你的测试覆盖率能够稳定地增长， 并且能够保证逃过单元测试的bug数
目会越来月少，在项目后期能有效的控制住代码崩坏。

第三种情况，和第一种情况差不多，也是保证现有的代码是不存在可测出的bug。

第四种情况，这个情况更多是用于部署了项目自动化的项目中，如果不具备条件的话，可
以不做。

为了获得单元测试的好处，在软件开发过程中应形成一套严格纪律意识。

首先，每个人负责的模块都需要编写对应的单元测试代码，并且要如同对待项目代码一样
对待测试代码：注重同样的代码规范、尽量考虑全面的测试条件。

其次，仔细保留记录是必要的，不仅仅只保留执行的测试，也包括保留对应的源码和其它
软件单元的变更历史。即，将单元测试代码归入项目版本库中是必要的。如果后续版本不
能通过一个以前测试通过的单元测试，版本控制系统可以提供对应时间段对源代码所做的
变更清单。

最后，每天养成查看单元测试案例失败测试并及时确定错误原因的习惯。如果没有这样的
流程，没有在团队工作流程中体现，单元测试系列将走向不同步，造成越来越多的错误和
越来越低效的单元测试用例。

对于一个方法，要找出所有可能出问题的地方， 也就是所有隐藏在深处的bug，是非常困
难的。对于经验丰富的人(经过很多痛苦教训之后)，他们通常能够洞察出系统哪些地方最
可能出现问题，然后集中对这些地方进行测试，比如初始化、负值情况、参数；但是对于
初学者，常常不知道在单元测试中去测试什么，想要发现会出问题的地方，可能会有些困
难。

这里有一些指导性的建议，给出六个值得测试的具体部位。 主要摘自参考资料[1]，添加
了一些解释，详细的参看该资料：
  
- Right：结果是否正确：
  也就是验证调用函数的结果。要注意的是，测试代码本身也是可能出错的，例如拿来和
  函数结果进行比较的由人工计算的测试数据。

- B：边界条件：
  找边界条件是单元测试中最有价值的工作之一，因为bug一般就会出现在边界上。 你的
  方法能否能够处理不同情况下的输入的边界条件，是考验方法逻辑正确性以及健壮性的
  重要标准。一些常见的边界输入如下：
  - 完全伪造或者不一致的输入数据。例如："!##$GKD#%_#$@"这类的输入。
  - 格式错误的数据。
  - 空值或者不完整的值。(0, 0.0, "", NULL)。
  - 一些和意料中的合理值想去甚远的数值，例如人的寿命为10000岁。
  - 如果要求是一个不允许出现重复数值的list，但传入的是一个存在重复数值的。
  - 如果要求的是一个有序的list，但传入的是一个无序的list，或者相反。
  - 事情到达的次序是错误的，或者碰巧和期望的次序不一致。

- I：检查反向关联：
  对于一些方法，可以使用反向的逻辑关系来验证。例如对结果进行平方来检查一个计算
  平方根的函数。

- C：用其他手段交叉检查一下结果：
  例如，计算一个量有多个算法，只有一种用在产品中，但是可以用其他可靠的算法来对
  该算法进行比较测试。

- E：强制产生错误条件：
  通过模拟现实中可能发生的问题，来测试项目代码是如何处理这些问题的。可能出现的
  问题有：内存耗光、磁盘用满、时钟出问题、网络不可用等。这些可以同过mock对象来
  进行模拟，后面会讲解mock对象。

- P：性能要求：
  这部分更多的可能是对大数据量的处理速度的测试。其实更详细的性能测试是有专门的
  来进行的，但是这里可以针对某个单元进行大概的测试。例如运行前记录时间，运行测
  试后记录时间，使用断言判断是否所花时间大于某个阈值。

以上是对单元测试中需要注意的几个地方的说明。针对边界条件，下面给出更进一步的讲
解：

- 一致性：
  产生的或者传入的值是否和预期的一致，包括格式。应该将每种可能的格式情况都考虑
  到。例如格式有头、尾要求，那么你应该分别编写头有尾有、头无尾有、头有尾无和头
  无尾无四种情况的测试代码。

- 顺序性：
  包括两个方面的情况。第一，输入的数据如果不是按照要求的输入顺序的话怎么处理；
  第二，某个数据在输入的数据集中的位置，例如搜索程序的搜索目标位于数据集中最前
  或者最后。

- 区间性：
  主要是检查输入值是否位于合理的最小值和最大值之内。 几乎所有的索引问题(无论是
  否为整型索引)都应该被大量测试，包括： 开始索引和结束索引有相同的值，第一个索
  引值大于最后一个索引值，索引值是负的，索引值大于允许值，计数值不能匹配确切索
  引的个数等。

- 依赖性：
  代码是否引用了一些不在代码本身控制范围之内的外部资源。这里指的是系统需要在某
  个条件下才能运行，需要测试如果条件不满足，程序的行为是否仍然正确。后条件指的
  是测试代码运行之后，会产生那些副效果，也需要对这些效果进行检查。

- 存在性：
  需要处理出入值或则维护的值不存在存在的情况，例如，指针值为NULL或为空，值为0,
  值不在已有的集合中等。

- 基数性：
  一般处理情况考虑三种值：0、1和对于一。

- 时间性：
  主要考虑相对和绝对的时间性：所有事情的发生是否是有序的？是否是在正确的时刻？
  是否恰好及时？还有并发问题，因为可能一些接口会拥有自己的状态。此外，现实的时
  间问题可能还涉及到UTC和DST的标准不同。

以上对各种边界条件只是简要的罗列介绍了一下，具体的解释和实例可以查看下面列出的
参考资料[1]。


如何做好单元测试
------------------------------------------------------------------------------
单元测试非常有用，但是如果使用不当也会浪费你大量的时间，对项目的正常进行造成不
好的影响。同时，如果没有恰当地编写和实现单元测试，在维护和调试这些测试上面，很
容易就会浪费很多的时间，从而影响产品代码和整个项目。

努力使自己的单元测试达到以下所列的品质，则会让你的测试之路变得轻松:

- 自动化：
  包括调用测试自动化和检查结果自动化。

- 彻底的：
  能够测试到所有可能出现问题的情况。事实上，对代码的覆盖率要到怎样的地步，取决
  于具体的决策，即是说，项目需求中需要覆盖到多少，是否有必要测试函数中所有的分
  支路径。

- 可重复：
  每个测试应该独立于所有其他的测试，且必须独立于周围的环境，使得测试能够以任意
  顺序一次又一次的运行，并且产生相同的结果。如果涉及到外部环境的调试，则需要自
  己构建测试沙盒。

- 独立的：
  测试应该是简洁而精炼的，这意味着每个测试都应该有很强的针对性。每个测试函数应
  该专注与代码中的一个函数，且独立于环境和其他测试，这样才能够做到多个测试实例
  同时进行。对CUnit来说每个suite的setup()和cleanup()能够起到这个作用。

- 专业的：
  测试代码应该具有和产品代码相同的水准，该遵守的编码规范同样也要遵守。需要注意
  的是，不是所有的函数都需要编写测试用例进行测试，例如简单的返回一个值的接口函
  数就不需要进行测试，编译器本身就能发现所有可能的错误。

关于单元测试的自动化：如果测试只是简单地执行一个测试程序，那么将执行命令写到项
目中的Makefile中，变成一个目标即可；如果测试需要复杂的命令和步骤完成的话，则编
写一个脚本来完成测试任务。那么，无论是Makefile中的目标还是测试脚本，都可以轻松
地归并到项目自动化中去了。

对于测试结果的检查的自动化： 如果输出报告是规范格式的话，利用文本处理工具(例如
grep, awk等)来编写分析脚本，就可以实现检查结果的自动化了。

所谓测试代码的覆盖率，指的是对被测代码可能发生问题所进行测试的多少。初学者往往
不能够一次性的编写出覆盖率较高的测试用例。但没有关系，测试用例的完善不是一蹴而
就的。测试代码的编写和维护是一个不间断的过程，主要内容包括下述几个方面：

- 删除过时的测试用例：
  因为需求的改变等原因可能会使一个测试用例不再适合被测试系统，这些测试用例就会
  过时。例如，某个变量的界限发生了改变，原来针对边界值的测试就无法完成对新边界
  测试。所以，在软件的每次修改后都应删除或者修正相应的过时测试用例。 

- 改进不受控制的测试用例：
  随着软件项目的进展，测试用例库中的用例会不断增加，其中会出现一些对输入或运行
  状态十分敏感的测试用例。这些测试不容易重复且结果难以控制，会影响回归测试的效
  率，需要进行改进，使其达到可重复和可控制的要求。

- 删除冗余的测试用例：
  如果存在两个或者更多个测试用例针对一组相同的输入和输出进行测试，那么这些测试
  用例是冗余的。冗余测试用例的存在降低了回归测试的效率。所以需要定期的整理测试
  用例库，并将冗余的用例删除掉。

- 增添新的测试用例：
  如果某个程序段、构件或关键的接口在现有的测试中没有被测试，那么应该编写新测试
  用例重新对其进行测试。并将新开发的测试用例合并到测试代码中。 
  对于已经通过单元测试的代码，如果出现了bug，在修正bug之后，应该将该错误的测试
  添加到测试代码中，以提高测试代码的覆盖率和完备性。并且思考一下，同样类型的错
  误是否在代码的其他地方可能发生。

- 更新已有测试用例：
  项目中的需求变化时有发生，因此需要对项目代码进行修改。项目代码的修改意味着对
  应的测试用例的代码也要随之更新，改变调用形式、修正判断格式、增加边界条件等。
  这样才能保证测试代码一直都是最新的状态，能够快速地反应出代码中的问题。

通过对测试用例库的维护不仅改善了测试用例的可用性，而且也提高了测试库的可信性和
覆盖率，同时还可以将一个测试用例库的效率和效用保持在一个较高的级别上。

每个测试的运行都应该是互相独立的，从而可以在任何时候，以任意的顺序运行单独的测
试。因此，在每个测试开始之前，你都需要重新设置某些测试环境，并且在测试完成之后
，释放一些资源。这些工作一般放在setup()和cleanup()里。在CUnit中，每一个suite有
各自的setup()和cleanup()。而对于每个test没有提供这种机制。

单元测试不仅仅是作为无错编码一种辅助手段在一次性的开发过程中使用，单元测试必须
是可重复的，无论是在软件修改，或是移植到新的运行环境的过程中。因此，所有的测试
都必须在整个软件系统的生命周期中进行维护。因此需要将测试代码归入版本控制，以便
可以随时进行可重复的单元测试。

如果项目中有代码评审(code  review)机制的话，测试代码也应当成为评审的一部分。测
试代码应该准循和项目代码一致的编程规范：良好的程序框架、合理的命令规则等。测试
代码在命名时，一般在被测试函数名字添加一个test即可作为新的测试函数的名字。测试
代码应当具有很好的可读性，哪怕性能差些或者形式上罗嗦一些。

对于一个规范的项目来说， 当然不希望单元测试代码和项目代码混合在一起(虽然命名规
则上要求前缀test以示区分)， 这样测试代码虽然可以很方便调用项目代码中的函数，但
是带来的混乱是得不偿失的。因此需要将项目代码和测试代码归入不同的目录中，分别进
行管理以及编译。这要求测试代码目录下的Makefile能让测试代码可以链接到项目代码的
目标文件，以调用项目代码中的函数。可以通过查看笔者所写的示例程序了解。

对于C语言来说， 模块内部的函数会使用static进行修饰，以便进行模块之间的隔离，使
内部函数不会暴露给外部模块。但是对于单元测试来说，这样做，测试模块便无法调用模
块的内部函数来进行测试了。解决方法是在编译测试程序时将这些接口暴露出来，而在编
译项目应用程序时使用static进行修饰。在示例程序中，通过宏条件编译来实现。这样做
对将对项目代码的污染降到了最小。但仍然还是不够优雅和简洁，希望读者能够给出更好
的解决方法。

当单元测试中的测试数据的数量很大时，如果每个测试数据都编写一个断言，那么代码量
是非常大的。这种情况下，可以考虑将测试数据写入到数据文件中，由测试代码从数据文
件中读入测试数据，而不是硬编码到代码中。这样不仅能够快速的实现大量数据的测试，
还可以不修改代码就改变测试内容，提供更好的灵活性和扩展性。


设计相关
------------------------------------------------------------------------------
上面已经提到过，单元测试除了能够帮助程序员理解和验证代码的功能以及操作方面的特
性，还能够提供许多改善代码的设计和架构的机会，能够对程序员的设计层面产生积极的
影响。

其中一个很热门的话题就是TDD(Test-Driven Development，测试驱动开发)，利用测试来
驱动软件程序的设计和实现。测试驱动开发是极限编程(XP)中倡导的程序开发方法，方法
主要是先写测试程序，然后再编码使其通过测试。关于TDD更多详细信息查看相关资料。

虽然在当下实验室的项目中并没有严格地采用极限编程，但是我们通过有意地设计出方便
测试的代码，可以让代码具有更好的结构，使设计更加简洁，让代码更容易扩展和维护。

在实际编程实践中，如果一个单元的测试代码看起来非常丑陋，甚至难以编写的话，那么
就应该把这种情况看成一种征兆。它暗示着项目代码的设计可能需要进行修改，改变一些
设计，直到让代码易于测试为止。

例如，初学者可能在不熟悉单元测试驱动开发时，没有考虑太多就编写出了一个函数。在
编写对应的单元测试代码时才发现该函数不适合进行单元测试。例如，这个函数做的事情
太多了，牵扯了很多功能在里面。此时，你要做的就是分解这个大的函数为多个小函数，
每个小函数专心地实现一个小功能。因为被测对象够简单，只需检查一个功能实现，因此
对一个小函数编写单元测试才会比较可行。

如果使用单元测试技术时，总是在重复编写项目代码、测试不能、分解、测试的过程，久
而久之你就会形成一开始在构思功能函数时就对函数进行分解的习惯思维，此时过程就变
成了分解、写、测试。显然这个过程效率更高，结果也跟好。不仅节省时间，最重要的是
没有影响到你的心情：你看，你一次就顺利完成了任务，不需要折返。此时，你的编程理
念中就有了分解任务的思想，这会让你的程序结构更合理、维护更方便、可读性更强、调
试更简易。

以上的情况也可能出现在你完成功能之后，重新查看自己代码时。如果你发现自己先前的
代码是不适合进行测试时，应该要鼓起勇气进行重构。


遗留代码
------------------------------------------------------------------------------
所谓遗留代码(legacy  code)，指的是前人所留下的项目代码。该项目可能正在开发中，
需要你了解业务后继续下阶段的开发，以完成该项目；或者已经完成并在实际应用中，但
是需要你进行维护。遗留代码往往是很多程序员的噩梦，是不愿意去触碰的东西。不仅仅
因为需要重新熟悉该项目业务，同时也因为遗留代码中的bug通常隐藏得很深而难以察觉。

当所维护的遗留代码没有单元测试时，如果是模块化清晰、进过了重构的代码，则会比较
容易添加单元测试，但是如果不是这种情况，那么对其添加单元测试是一个十分耗时耗力
的工程，如果有必要可以进行重构。否则只需要对关键部分或者可能出现问题的部分添加
单元测试。而在日后出现了问题之后，再对该问题进行修复和对问题所在模块添加单元测
试，以保证进行的修复是有效的。这样一步一步将单元测试覆盖到整个项目中。记住，不
需要一次性就完成整个的覆盖，可以一步一步地进行。


mock对象
------------------------------------------------------------------------------
单元测试所测试的一个方法通常会调用一些外部或者系统级别的接口，诸如网络、数据库
、硬盘文件等，而我们在测试时这些接口的环境也许并不存在，但是测试还是要需要覆盖
到这些代码上，这便对单元测试的可重复性以及独立性造成很大的影响。此时，就需要自
己编写接口或者对象来模拟外部的真实环境，比如系统时间、网络等，来对实际代码中操
作的对象找个替身。

这个时候就需要mock对象。mock对象是真实对象在调试期的替代品。最开始出现在Java开
发领域，后来在其他语言中都有引入。mock提供了一种模拟和控制外部或系统级别对象或
者接口的方法，这样你大可在不必与真实环境交互的前提下就完成所有依赖外部环境的业
务流程的覆盖测试。

使用mock对象，一般需要三个关键步骤：

1. 使用一个接口来描述对象；

2. 为项目代码实现这个接口；

3. 以测试为目的，在mock对象中实现这个接口。

因为测试对象只会通过接口来调用对象，所以它完全可以不知道它引用的究竟是真实对象
还是mock对象。

不过，一般来说，mock对象在面向对象的测试框架中使用居多。 CUnit的使用文档中并没
没有提及到mock对象的使用。 目前C下的测试框架中对mock的支持似乎少之又少。单元测
试框架Cgreen中虽然支持mock，但是它要求你的待测试的业务接口必须附加一个stub参数
，这样具有"侵入性"的设计很是别扭，而且对于外部接口，更是无法改变其接口原型。不
过google的cmockery是支持mock的，有兴趣的可以去尝试一下。这里就不多做说明了。


小结
------------------------------------------------------------------------------
本文档主要讲解了什么是单元测试、为什么要进行单元测试、何时以及如何有效、高效地
进行单元测试，并讨论了具体应用中的几个tips。

对于初学者，在最初学习单元测试的时候，可能会对一些相关概念或要求理解不透彻或偏
差，需要在实践中慢慢去印证和修正。实践出真知。

因为此前实验室没有在项目中使用单元测试的经验，并且网上相关资料也比较少，特别是
关于C语言的单元测试，因此这里更多的是纸上谈兵， 文档上的大部分内容也是摘自各种
资料、网友的总结以及笔者自己在经历过的项目中的产生的一些理解和想法，可能会有一
些偏差甚至错误的地方，同时还有些具体问题可能并没有提及。希望读者能够在通过自己
的阅读以及今后在项目中的具体实践，能够对单元测试有更透彻的理解，从而修正、改进
和丰富本文档内容。本文档也会在项目实践中一直进行维护。


参考资料：
- [1]:《单元测试之道》，Andrew Hunt、David Thomas 著，陈伟柱、陶文 译。
- [2]：很好的一篇博文：《软件开发中单元测试unit testing》：
       http://sunxiunan.com/?p=1678
- [3]：网友博客：《常用C语言单元测试工具介绍》：
       http://blog.csdn.net/cwmbecoming/archive/2007/10/19/1832395.aspx
- [4]：博文：《Cmockery中文手册(翻译)》：
       http://see-see.appspot.com/?p=12001
- [5]：CUnit官网用户指南文档：http://cunit.sourceforge.net/doc/index.html
       笔者对该文档进行了中文翻译，可以在实验室armftp中找到：
       ftp://down:down@armftp/work/unit_test/CUnit_user_guide_20101122.txt
       armftp的地址，内网中是192.168.0.188，实验室网段内是172.20.69.133。
- [6]：《项目自动化之道》，Mike Clark 著，张菲 译。
- [7]：wiki中的条目：http://zh.wikipedia.org/zh/单元测试
- [8]：博客：《C语言中的断言》：
       http://blog.chinaunix.net/u1/49865/showart_424689.html
